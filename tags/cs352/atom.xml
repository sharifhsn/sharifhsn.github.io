<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Sharif&#x27;s Page - cs352</title>
	<subtitle>Sharif Haason&#x27;s personal website for various notes and ideas</subtitle>
	<link href="https://sharifhsn.github.io/tags/cs352/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://sharifhsn.github.io/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-04-22T00:00:00+00:00</updated>
	<id>https://sharifhsn.github.io/tags/cs352/atom.xml</id>
	<entry xml:lang="en">
		<title>Network Security</title>
		<published>2022-04-22T00:00:00+00:00</published>
		<updated>2022-04-22T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/network-security/" type="text/html"/>
		<id>https://sharifhsn.github.io/network-security/</id>
		<content type="html">&lt;p&gt;The internet has taken over the world, but with it have come malicious actors. People want to spy on you, scam you, steal from you, or harm you through the internet. Through &lt;strong&gt;network security&lt;&#x2F;strong&gt;, we can shield potential victims from at least some of these harms.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;attacks&quot;&gt;Attacks&lt;&#x2F;h2&gt;
&lt;p&gt;Attacks on a network can be performed &lt;em&gt;passively&lt;&#x2F;em&gt;, for example in eavesdropping. The network cannot tell the difference between this passive attack and ordinary traffic because no more traffic is being injected.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Active&lt;&#x2F;em&gt; attacks, by contrast, are done by changing the kind or amount of traffic. This typically manifests as a &lt;strong&gt;DoS&lt;&#x2F;strong&gt; &lt;strong&gt;(Denial of Service)&lt;&#x2F;strong&gt; attack. This is usually a significant increase in traffic which shuts down the network due to congestion. If only one host is attacking the network, then the network can easily shut a particular malicious host out. DoS attacks are usually distributed, hence &lt;strong&gt;DDoS&lt;&#x2F;strong&gt; &lt;strong&gt;(Distributed Denial of Service)&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Teardrop attacks are a modern form of DDoS. Instead of sending lots of useless traffic, all they do is open a new connection with a socket. Even though this is a small operation, when done on large scale, it can tax the memory of a server. We mentioned previously that in order to compensate for fragmentation, routers will keep a memory buffer to store fragments. This can be exploited by malicious packets that are all fragments which will run out the memory of the router.&lt;&#x2F;p&gt;
&lt;p&gt;The three main aspects of network security are &lt;strong&gt;authentication&lt;&#x2F;strong&gt;, &lt;strong&gt;confidentiality&lt;&#x2F;strong&gt;, and &lt;strong&gt;integrity&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Authentication: How do you prove that someone is who they say they are?&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Confidentiality: How can you hide data from prying eyes?&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Integrity: How can you prove that data has not been altered midstream?&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In order to protect these, we need a &lt;strong&gt;security model&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;An algorithm to ensure security that must be well-known.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Trusted parties know how to generate secret information.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Distribute that information through a secure method.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Specify a protocol for trusted parties to decrypt data.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;encryption&quot;&gt;Encryption&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Encryption&lt;&#x2F;strong&gt; or &lt;strong&gt;cryptography&lt;&#x2F;strong&gt; is the encoding of a message in such a way that only the communicating parties can interpret it. That way, if a malicious party tries to read the message, they will be unable to understand it because they cannot decrypt it.&lt;&#x2F;p&gt;
&lt;p&gt;Encryption has two sides, the encryption algorithm and the decryption key. The algorithm should be publicly available in order to prove that it works. When you feed the decryption key into the algorithm, it will spit out a string associated with only that key.&lt;&#x2F;p&gt;
&lt;p&gt;The secret key itself should be long enough that the algorithm cannot easily be broken, but also short enough so that it can be transmitted easily. Fun fact: before minimum password lengths were instituted, the most common password was &amp;quot;god&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;The most basic kind of encryption algorithm is a substitution cipher. By simply replacing letters in a message with another letter with a known mapping, a message can be encoded and decoded. However, it is relatively trivial to break this cipher because the English language has patterns that can identify certain letters better than others.&lt;&#x2F;p&gt;
&lt;p&gt;You can increase the complexity of this algorithm through polyalphabetic encryption, where the cipher itself changes after every letter. Famously, this is how the Enigma cipher used by the Nazis during World War II worked.&lt;&#x2F;p&gt;
&lt;p&gt;Transposition ciphers will change the &lt;em&gt;order&lt;&#x2F;em&gt; of the words as well. This might seem like a really good cipher, unfortunately it can similarly be broken by looking at the structure of language.&lt;&#x2F;p&gt;
&lt;p&gt;In order to actually encrypt data, real-world encryption algorithms use a combination of these techniques.&lt;&#x2F;p&gt;
&lt;p&gt;But how do we generate the decryption key? There needs to be one for every user, but they need to be as random as possible and nigh impossible to crack, so we can&#x27;t use plaintext passwords.&lt;&#x2F;p&gt;
&lt;p&gt;We can use &lt;em&gt;pseudorandom number generators&lt;&#x2F;em&gt; in order to create a key. A pseudorandom number generator is an algorithm which, starting with some seed, will produce a string of numbers based on that seed which &lt;em&gt;appear&lt;&#x2F;em&gt; to be random. The seed will typically based on some environmental noise that can&#x27;t be easily predicted, such as the time of day at which the algorithm runs. The generator should be &lt;em&gt;highly&lt;&#x2F;em&gt; sensitive to changes in seed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;symmetric-key&quot;&gt;Symmetric Key&lt;&#x2F;h2&gt;
&lt;p&gt;Using the same key, two parties should be able to both encrypt and decrypt the message. By applying the key to the message, the message should be encrypted, then decrypted.&lt;&#x2F;p&gt;
&lt;p&gt;There are two main kinds of symmetric ciphers: &lt;em&gt;stream ciphers&lt;&#x2F;em&gt;, and &lt;em&gt;block ciphers&lt;&#x2F;em&gt;. As the name implies, stream ciphers do bitwise operations on the message and the key in order to get the ciphertext. The bitwise operations can be symmetric, like ⊗. One example of a stream cipher is RC4 which can be used in SSL.&lt;&#x2F;p&gt;
&lt;p&gt;Block ciphers have a 1-to-1 mapping of certain blocks of \(k\) bits to other blocks, typically 64 bits. This is a good method, but the problem is that the number of mappings balloons massively: in general, it is \(2^k!\), which is absolutely massive! It is both exponential &lt;em&gt;and&lt;&#x2F;em&gt; factorial. To simulate such a table, you can use a pseudorandom function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;des&quot;&gt;DES&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;strong&gt;Data Encryption Standard&lt;&#x2F;strong&gt; is the US encryption standard. It uses a 56-bit symmetric key for 64-bit plaintext input, and it is a block cipher. It is fairly secure for small attacks, but it can be brute force decrypted in less than a day. Its advantage is that there is no analytic exploit in the standard.&lt;&#x2F;p&gt;
&lt;p&gt;In order to make DES more secure, we can increase the number of keys to 3, making &lt;strong&gt;3DES&lt;&#x2F;strong&gt;. The message is encrypted, decrypted, then encrypted again when run through all three keys. Effectively, there are \(56 × 3 = 168\) bits to crack, which is much stronger than 56.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;replay-attacks&quot;&gt;Replay Attacks&lt;&#x2F;h2&gt;
&lt;p&gt;This method of symmetric key is vulnerable to a certain kind of attack: the &lt;strong&gt;replay attack&lt;&#x2F;strong&gt;. Let&#x27;s say I encrypt a message and mail it to my boss. My boss decrypts the message, and sends me back a confidential message, so we can pass information to each other. But my boss doesn&#x27;t know my address, he only knows that he can trust me because the message is encrypted using our key.&lt;&#x2F;p&gt;
&lt;p&gt;What if a malicious hacker somehow obtains my encrypted message? If she sends that message to my boss, then my boss will email the hacker back with the confidential information because he thinks that only I have the ability to encrypt messages in that way.&lt;&#x2F;p&gt;
&lt;p&gt;The way to protect against this is by using a &lt;strong&gt;NONCE&lt;&#x2F;strong&gt; value, which is a &lt;strong&gt;N&lt;&#x2F;strong&gt;umber used only &lt;strong&gt;ONCE&lt;&#x2F;strong&gt;. Let&#x27;s say I write a random number on my message every time I send a message to my boss. The hacker obtains my message and sends the same message later, with the same random number. My boss knows that the NONCE value cannot be the same and therefore does not trust the hacker with our confidential information.&lt;&#x2F;p&gt;
&lt;p&gt;The NONCE doesn&#x27;t have to be a random number. Many times, it can be a challenge query like asking for my mother&#x27;s maiden name. Having multiple challenges that are cycled through adds an extra layer of protection.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rsa&quot;&gt;RSA&lt;&#x2F;h2&gt;
&lt;p&gt;Nowadays, almost all cryptography is done by having two keys: a &lt;strong&gt;public key&lt;&#x2F;strong&gt;, and a &lt;strong&gt;private key&lt;&#x2F;strong&gt;. The public key is used to &lt;em&gt;encrypt&lt;&#x2F;em&gt; messages, and private key is used to &lt;em&gt;decrypt&lt;&#x2F;em&gt; messages. The public key is, as might be obvious, publicly available. Someone who wants to send a secure message to me can use my public key to encrypt it. However, only I can use my own private key to decrypt it. Importantly, &lt;em&gt;you should not&lt;&#x2F;em&gt; be able to determine the private key by analyzing the public key. They should be wholly different in nature.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;RSA&lt;&#x2F;strong&gt; is the most commonly used implementation of this kind of cryptography. To encrypt a message, take the message and raise it to the power of the public key, &lt;code&gt;mod&lt;&#x2F;code&gt; some \(n\). To decrypt said bit pattern, raise it to the power of the private key, again &lt;code&gt;mod&lt;&#x2F;code&gt; the same \(n\).&lt;&#x2F;p&gt;
&lt;p&gt;Authentication can be done using the passing of challenge messages. A new secret key will be created which is encrypted and decrypted in order to encrypt the data.&lt;&#x2F;p&gt;
&lt;p&gt;One problem with RSA is that it&#x27;s really expensive and slow computation-wise, which is good for security but bad for convenience. In practice, most uses of RSA encryption only use the actual algorithm to encrypt some secret key, which is then used as a simpler cipher for the data between the two parties.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hash&quot;&gt;Hash&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Hashing&lt;&#x2F;strong&gt; is the process of creating a unique-ish value from some data that can be used to verify that data as a signature. It should be fast, not easily irreversible, and not have collisions i.e. no two hashes should be the same.&lt;&#x2F;p&gt;
&lt;p&gt;The two most common hash functions are &lt;strong&gt;MD5&lt;&#x2F;strong&gt; and &lt;strong&gt;SHA-1&lt;&#x2F;strong&gt;, which are 128 bits and 160 bits, respectively.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Multimedia Networking</title>
		<published>2022-04-07T00:00:00+00:00</published>
		<updated>2022-04-07T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/multimedia/" type="text/html"/>
		<id>https://sharifhsn.github.io/multimedia/</id>
		<content type="html">&lt;p&gt;Streaming multimedia is a relatively new concept in internet technology, but now has become central to the daily media consumption of people around the world.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;multimedia&quot;&gt;Multimedia&lt;&#x2F;h2&gt;
&lt;p&gt;In contrast to the ordinary messages that encode text, &lt;strong&gt;multimedia&lt;&#x2F;strong&gt; streaming uses audio or video. Most of the traffic on the internet today is dominated by multimedia streaming, so it&#x27;s a big deal. Multimedia streaming is different from other kinds of streaming in that latency is of greatest importance, but it is also loss tolerant; if the streaming video is a bit distorted, it&#x27;s not a big deal. When the delay hits above 150 ms users begin to complain.&lt;&#x2F;p&gt;
&lt;p&gt;VoIP is a special case where there is media being streamed &lt;em&gt;both&lt;&#x2F;em&gt; ways, where two people speak on the same connection through data networks.&lt;&#x2F;p&gt;
&lt;p&gt;We must handle signals differently because we don&#x27;t have a simple Huffman coding like with text. There are three elements at play that determine the quality of the signal:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Sampling: how often do you sample the signal for data?&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Quantization: how many levels&#x2F;bits represent each sample?&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Compression: how much are the quantized values compressed?&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In order to minimize the amount of data being sent, video streaming will often only send the changes from one frame to the next. Otherwise, the level of fidelity would be infeasible on current internet technology.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;audio&quot;&gt;Audio&lt;&#x2F;h2&gt;
&lt;p&gt;Audio is generally ranges from 20 Hz to 22.05 kHz, and speech goes between 200 Hz and 8kHz. Sampling generally occurs up to 8kHz to capture speech, the most important element of audio in general, though it is possible to capture 16kHz for high-fidelity audio.&lt;&#x2F;p&gt;
&lt;p&gt;Quantization can either be 8 bits or 16 bits, which means there are either \(2^8\) or \(2^{16}\) levels. That&#x27;s a difference between 256 and 65,536!&lt;&#x2F;p&gt;
&lt;p&gt;The bit rate of samples typically depends on the type of audio being sent. For simple VoIP it will typically be 64Kbps, because it quantized at 8 bits and sampled 8k times per second. Audio will generally be 705.6Kbps from 16 bits of quantization and 44.1k samples per second. Stereo is the most fidelity because it is audio in both ears, so double the bit rate at 1.4112 Mbps. By removing frequencies that the human ear cannot distinguish, the amount of data can be reduced dramatically without altering the end sound.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;video&quot;&gt;Video&lt;&#x2F;h2&gt;
&lt;p&gt;Images are 2D arrays of pixels at heart. The amount of pixels is &lt;em&gt;resolution&lt;&#x2F;em&gt;, which is typically expressed through a 16:9 aspect ratio as with 1080p or 4K&#x2F;UHD.&lt;&#x2F;p&gt;
&lt;p&gt;Every color has 8 bits, and there are three colors RGB so each pixel will contain 24 bits. That means the raw data for a color image even of size 320×240 will be 7680 bytes! That&#x27;s a lot for one image. Compression through JPEG, Gif, etc. is typically used to help here.&lt;&#x2F;p&gt;
&lt;p&gt;Video is composed of images that are displayed at a certain &lt;em&gt;frame rate&lt;&#x2F;em&gt;. Movies run at 24 FPS, though some rare movies display at 48 FPS. Video games are commonly at either 30 FPS or 60 FPS, but can go even higher.&lt;&#x2F;p&gt;
&lt;p&gt;If we imagine a 4k television displaying color images at 60 FPS video, the amount of data transmitted would be \(4096 \cdot 2160 \cdot 60 \cdot 24\) which is 12 Gbps!!! We obviously need some kind of compression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;streaming&quot;&gt;Streaming&lt;&#x2F;h2&gt;
&lt;p&gt;The client will typically downloading the first portion of the multimedia and begin consuming it. The rest is downloaded while the client consumes the data, so you don&#x27;t need to wait for the whole file to be downloaded. If you&#x27;ve ever watched a YouTube video, you can see this in real time as the gray bar overlaid on top of the timeline of the video. The client has a buffer to store that downloaded video which is constantly drained to show the video and filled at times corresponding to network delays.&lt;&#x2F;p&gt;
&lt;p&gt;However, this can cause &lt;em&gt;buffering&lt;&#x2F;em&gt; when the network delay is variable and the client consumes all of its data before the server can produce more. The video will be buffered until more data is received, and you see a still frame on the video while a loading symbol plays over it.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rtp&quot;&gt;RTP&lt;&#x2F;h2&gt;
&lt;p&gt;UDP streaming is the traditional type of streaming. As multimedia does not necessarily need to be reliable, UDP is better for reducing latency which is most important for the consumer. The packet has the timestamp of the multimedia so it can be ordered correctly in the client buffer. It also needs certain information like the encoding or whether the audio is for left or right microphone. The protocol used for multimedia that incorporates these is called &lt;strong&gt;RTP&lt;&#x2F;strong&gt; or &lt;strong&gt;Real-time Transport Protocol&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;RTP is a flexible protocol that allows for many types of multimedia to be transmitted.&lt;&#x2F;p&gt;
&lt;p&gt;The header includes a timestamp field which increments per sample, which allows for correct timing. It also uses sequence numbers to distinguish between packet loss and silence.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;http&quot;&gt;HTTP&lt;&#x2F;h2&gt;
&lt;p&gt;Most people stream video over their browsers nowadays, which uses HTTP. You might remember that HTTP uses TCP, which is slower than UDP but more reliable. The streaming is slower but more convenient.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dash&quot;&gt;DASH&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Dynamic Adaptive Streaming&lt;&#x2F;strong&gt; allows for good bandwidth over HTTP. The client is the one that adjusts the request rate from multiple content formats&#x2F;encoding. For example, the client can request data at a lower bit rate or quality like 480p if it feels that 720p is too slow.&lt;&#x2F;p&gt;
&lt;p&gt;The MPD or Media Presentation Descriptor is sent over HTTP and gives information about the different format segments. The client can then request each segment, and the segments can come from different ASes, which works well for CDNs. This is how ads are served over YouTube; the client is the one that decides whether to get an ad or not. This is also why blocking ads on YouTube can be done by an extension to your browser.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dns&quot;&gt;DNS&lt;&#x2F;h2&gt;
&lt;p&gt;The ID for every YouTube video is a BASE64 11 character string, giving a space of \(64^{11}\) possible videos. The ID is mapped to 192 DNS host names so that multiple servers can be accessed for videos. This ID is a special hash of the video ID.&lt;&#x2F;p&gt;
&lt;p&gt;Multiple ASes can broadcast the fact that they are all reachable to a BGP router, and a BGP router can then choose the shortest path. This is called &lt;strong&gt;anycast&lt;&#x2F;strong&gt;. This means that for accessing video servers, you can pick the country where the video is hosted quite easily. Let&#x27;s say you want to access a Japanese video in Japan. It&#x27;s obviously best to access the Japan server, so that&#x27;s the closest. However, all 192 servers that host the video will broadcast, so that if the Japan server goes down in an earthquake or something, the other servers are still available for the BGP router to pick from, so they can access, for example, the South Korean server.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;voip&quot;&gt;VoIP&lt;&#x2F;h2&gt;
&lt;p&gt;Traditional telephones work over PSTN (Public Switched Telephone Network), which is autonomous and only designed for telephones. However, as the Internet has gradually taken over the world, a demand was created to include telephony in the Internet. Thus, the &lt;strong&gt;VoIP&lt;&#x2F;strong&gt; (Voice IP) protocol was born.&lt;&#x2F;p&gt;
&lt;p&gt;The voice sound waves are converted into packets and transported as audio through lossy RTP, similar to other forms of multimedia.&lt;&#x2F;p&gt;
&lt;p&gt;In order to establish the connection to begin with, &lt;strong&gt;SIP&lt;&#x2F;strong&gt; or Session Initiation Protocol sets up the VoIP session between two hosts. SIP URLS are similar to email addresses that identify users on a network. Most of the work is lent to the caller in order to type in some identifying information as they typically have a display&#x2F;keyboard. The URL is mapped to an IP address similar to DNS and email.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Control in Prolog</title>
		<published>2022-04-05T00:00:00+00:00</published>
		<updated>2022-04-05T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/prolog-control/" type="text/html"/>
		<id>https://sharifhsn.github.io/prolog-control/</id>
		<content type="html">&lt;p&gt;Conditional statements are very powerful and are in used in almost every language. How does Prolog implement the same idea?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;logic-control&quot;&gt;Logic + Control&lt;&#x2F;h2&gt;
&lt;p&gt;The basic idea behind a control statement is that there is &lt;em&gt;logic&lt;&#x2F;em&gt;, such as facts, rules, and queries, which are composed of clauses&#x2F;&lt;strong&gt;goals&lt;&#x2F;strong&gt;, as well as &lt;em&gt;control&lt;&#x2F;em&gt;, which is how Prolog chooses the logic among several options. The control is implemented by the order of the facts&#x2F;goals, which is &lt;strong&gt;extremely important&lt;&#x2F;strong&gt;. Prolog will &lt;em&gt;always&lt;&#x2F;em&gt; choose the first applicable rule in a program, and it will &lt;em&gt;always&lt;&#x2F;em&gt; choose the leftmost clause&#x2F;goal in a query.&lt;&#x2F;p&gt;
&lt;p&gt;Brevity is key. If there are two rules that do the same thing, or one rule that is implied by another rule, you should probably take it out unless executing something more than once is your explicit intention.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;abstract-interpreter&quot;&gt;Abstract Interpreter&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;A substitution \(σ\) is a finite set of pairs of terms \(\{X_1&#x2F;t_1, ..., X_n&#x2F;t_n\}\) where each \(t_i\) is a term and each \(X_i\) is a variable such that \(X_i ≠ t_i\) and \(X_i ≠ X_j\) if \(i ≠ j\).&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;An empty substitution is denoted by the letter \(ε\).&lt;&#x2F;p&gt;
&lt;p&gt;Some important rules:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A variable cannot substitute itself e.g. \(Z&#x2F;Z\) is illegal.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Only a variable can be substituted e.g. \(m&#x2F;n\) is illegal because \(m\) is an atom.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The meaning of applying a term to a substitution is that every occurrence of \(X_i\) in the compound term is replaced with the corresponding substituent in \(σ\) simultaneously. This application is known as &lt;strong&gt;instantiation&lt;&#x2F;strong&gt;, and that new compound term \(Eσ\) is an &lt;strong&gt;instance&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Bringing back the earlier rules about unification, you can see how unification is derived from substitution. Variables can unify with anything, so they are the term that is substituted in Prolog. There is an exception to this, which is known as the &lt;strong&gt;occurs check&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can use a substitution \(σ\) as a &lt;strong&gt;unifier&lt;&#x2F;strong&gt; for two terms if the application of \(σ\) to those terms makes them &lt;em&gt;syntactically equal&lt;&#x2F;em&gt;. This is distinct from &lt;em&gt;semantic&lt;&#x2F;em&gt; equality. When we talk about unifiers, we are only talking about the actual letters, not the meaning of the term. For \(S = f(X,Y)\) and \(T=f(g(Z),Z)\), if we have a \(σ = \{X&#x2F;g(Z),Y&#x2F;Z\}\) then \(S\) and \(T\) will be unified. Since the unification only cares about syntax, more than one unifier may exist for two terms. We could have just as well substituted the other way and it would still be a unifier.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;unifier-computation&quot;&gt;Unifier Computation&lt;&#x2F;h2&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;unify(X, Y, θ) =
&lt;&#x2F;span&gt;&lt;span&gt;  X = Xθ
&lt;&#x2F;span&gt;&lt;span&gt;  Y = Yθ
&lt;&#x2F;span&gt;&lt;span&gt;  case X is a variable that does not occur in Y:
&lt;&#x2F;span&gt;&lt;span&gt;    return (θ{X&#x2F;Y} ∪ {X&#x2F;Y}) &#x2F;&#x2F; this replaces X with Y in the unifier, and then adds a new substitution just in case X will appear later
&lt;&#x2F;span&gt;&lt;span&gt;  case Y is a variable that does not occur in X:
&lt;&#x2F;span&gt;&lt;span&gt;    return (θ{Y&#x2F;X} ∪ {Y&#x2F;X}) &#x2F;&#x2F; this replaces Y with X in the unifier. this is a rare case when the variables substitute each other
&lt;&#x2F;span&gt;&lt;span&gt;  case X and Y are identical constants
&lt;&#x2F;span&gt;&lt;span&gt;    return Θ
&lt;&#x2F;span&gt;&lt;span&gt;  case X and Y are compound terms like f(X1, ..., Xn) and f(Y1, ..., Yn)
&lt;&#x2F;span&gt;&lt;span&gt;    return (fold_left (fun Θ (X,Y) -&amp;gt; unify(X, Y, Θ)) θ [(X1, Y1), ..., (Xn, Yn)]
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;&#x2F; this applies the unification process to the compound terms
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;&#x2F; the function is just folding left with θ as acc and the set of compound terms as the list
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the basic pseudocode for the unify function. It&#x27;s recursive, and side-effect free. However, it&#x27;s not complete for writing an interpreter. For that, we also need backtracking.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;backtracking&quot;&gt;Backtracking&lt;&#x2F;h2&gt;
&lt;p&gt;The resolvent will maintain a list to satisfy our query. When we try to resolve a compound term, any goals within will be queued onto the resolvent to be resolved. This is &lt;em&gt;non-deterministic&lt;&#x2F;em&gt;, there is no order that will necessarily be followed other than that sub-goals within a single term will be inorder.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;missionaries-and-cannibals&quot;&gt;Missionaries and Cannibals&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s imagine a problem where we have three missionaries and three cannibals that need to cross a river in one boat. If the cannibals outnumber the missionaries, they will get eaten. How can we get every person across the river?&lt;&#x2F;p&gt;
&lt;p&gt;The concept of a &lt;em&gt;safe state&lt;&#x2F;em&gt; will be important here. A state is safe when no missionaries are eaten. By labelling certain states as unsafe, we can cut those paths out of our search algorithm. We should also define &lt;em&gt;transitions&lt;&#x2F;em&gt; between states, where a predicate moves a state from A to B. &lt;&#x2F;p&gt;
&lt;p&gt;Our states are essentially a pair representing position.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-l).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;finish&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;-_).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The elements in order are missionaries on the original side, cannibals on the original side, missionaries on the target side, cannibals on the other side, and the location of the boat.&lt;&#x2F;p&gt;
&lt;p&gt;The safety of the state is based on whether there are more cannibals than missionaries.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;safe&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-_-M2-C2-_) :- M2 &amp;gt;= C2.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;safe&lt;&#x2F;span&gt;&lt;span&gt;(M1-C1-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;-_-_) :- M1 &amp;gt;= C1.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;safe&lt;&#x2F;span&gt;&lt;span&gt;(M1-C1-M2-C2-_) :- M1 &amp;gt;= C1, M2 &amp;gt;= C2.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Every state here represents a point at which there are at least as many missionaries as cannibals on each side of the river.&lt;&#x2F;p&gt;
&lt;p&gt;The change in state can be caused by a &lt;code&gt;carry&#x2F;2&lt;&#x2F;code&gt; predicate which details how many missionaries and cannibals are being moved, respectively. In our case, the boat can only move up to 2 people so we need to represent every possible case of that.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;carry&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;carry&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;carry&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;carry&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;carry&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, we need a way to represent moving on both sides of the river, so we will have two transitions.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;prolog&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-prolog &quot;&gt;&lt;code class=&quot;language-prolog&quot; data-lang=&quot;prolog&quot;&gt;&lt;span&gt;step(M1-C1-M2-C2-l, M3-C3-M4-C4-r) :-
&lt;&#x2F;span&gt;&lt;span&gt;    carry(X, Y),
&lt;&#x2F;span&gt;&lt;span&gt;    M1 &amp;gt;= X, M3 is M1 - X, M4 is M2 + X,
&lt;&#x2F;span&gt;&lt;span&gt;    C1 &amp;gt;= Y, C3 is C1 - Y, C4 is C2 + Y.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;step(M1-C1-M2-C2-r, M3-C3-M4-C4-l) :-
&lt;&#x2F;span&gt;&lt;span&gt;    carry(X, Y),
&lt;&#x2F;span&gt;&lt;span&gt;    M2 &amp;gt;= X, M4 is M2 - X, M3 is M1 + X,
&lt;&#x2F;span&gt;&lt;span&gt;    C2 &amp;gt;= Y, C4 is C2 - Y, C3 is C1 + Y.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;step&lt;&#x2F;code&gt; predicate checks every valid &lt;code&gt;carry&lt;&#x2F;code&gt;, then will execute that transition from the current state.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;travel&lt;&#x2F;span&gt;&lt;span&gt;(A, A, _, []).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;travel&lt;&#x2F;span&gt;&lt;span&gt;(A, C, Visited, [B | Steps]) :-
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>The Link Layer</title>
		<published>2022-03-28T00:00:00+00:00</published>
		<updated>2022-03-28T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/link-layer/" type="text/html"/>
		<id>https://sharifhsn.github.io/link-layer/</id>
		<content type="html">&lt;p&gt;Through all the layers of the internet, the most essential is the &lt;strong&gt;link layer&lt;&#x2F;strong&gt;: converting bits to and from signals, detecting errors, flow control, and addressing.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;encoding&quot;&gt;Encoding&lt;&#x2F;h2&gt;
&lt;p&gt;We have spoken mostly through the guise of bits per second being sent across the internet and have left it at that. But what does it mean to send a bit over air waves? This isn&#x27;t like a traditional electrical circuit or transistor in your computer; the internet uses signals.&lt;&#x2F;p&gt;
&lt;p&gt;The nuances of digital signal processing are beyond these notes, so we will simplify here. We can imagine signals like a pseudo-transistor where low signals are 0 and high signals are 1. However, this causes two issues. One is that time synchronization is impossible for waves that travel at the speed of light, and the other is that because signals are not emitting all the time, we need a way to differentiate between signals and simple noise.&lt;&#x2F;p&gt;
&lt;p&gt;The time synchronization is mandated by a clock standard such as the Manchester encoding, which is slower than the speed of light but allows each link to know exactly when a signal is coming.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;framing&quot;&gt;Framing&lt;&#x2F;h2&gt;
&lt;p&gt;A &lt;strong&gt;frame&lt;&#x2F;strong&gt; is a group of bits in sequence. Frames are useful for manipulating data at the link layer, but they can escalate small bit errors to big problems. If a frame is too big, then it will error out too often, so we will often have smaller frames.&lt;&#x2F;p&gt;
&lt;p&gt;We also need a way to delineate the beginning and ending of frames. There are two ways, character stuffing and bit stuffing.&lt;&#x2F;p&gt;
&lt;p&gt;With character stuffing, a special meta character will be used to delineate frames. &lt;code&gt;^&lt;&#x2F;code&gt; is used for the beginning of frame (BOF) and &lt;code&gt;$&lt;&#x2F;code&gt; is used for EOF. If you need a &lt;code&gt;$&lt;&#x2F;code&gt; in your text, then simply add an escape character, like another &lt;code&gt;$&lt;&#x2F;code&gt; right beforehand.&lt;&#x2F;p&gt;
&lt;p&gt;With bit stuffing, a unique bit sequence &lt;code&gt;0x7E&lt;&#x2F;code&gt; or &lt;code&gt;0b01111110&lt;&#x2F;code&gt; will delineate frames. If that sequence appears in the data, it will insert a 0 within like &lt;code&gt;0b011111010&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;error-control&quot;&gt;Error Control&lt;&#x2F;h2&gt;
&lt;p&gt;Inevitably, bits will be corrupted on a physical link. This is a reality of circuit engineering. We have discussed several ways to handle errors on the application and protocol layer; what about on the link layer? We can either request retransmission as with TCP, or we can make corrections to the errors automatically, which may or may not be possible.&lt;&#x2F;p&gt;
&lt;p&gt;Parity bits can ensure a fixed sequence so that the extra bit can protect against errors. For example, with even parity, there will always be an even number of 1s, so if a bit flip changes that, you know that there was an error. But multiple bit errors can escape this detection.&lt;&#x2F;p&gt;
&lt;p&gt;Another method is when the sender will send a checksum computed from the message divided into chunks along with the message so that the receiver can use the checksum, just like with other layers.&lt;&#x2F;p&gt;
&lt;p&gt;Polynomial codes utilize the high degree of uncertainty when computing &lt;code&gt;mod&lt;&#x2F;code&gt; of a polynomial. The remainder must be added to the message and it can be checked by the receiver. This is a more complex form of error detection mathematically.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;addressing&quot;&gt;Addressing&lt;&#x2F;h2&gt;
&lt;p&gt;We have heretofore defined a host as an IP address. But how do we identifies hosts at the link layer? For links we use a &lt;strong&gt;MAC address&lt;&#x2F;strong&gt;, which is a unique 48 bit address to a device which will communicate through the internet. MAC addresses are far less sophisticated than IP addresses. They cannot be grouped or categorized like with NAT. The MAC address of the destination is included in the frame that is sent. They are also unique to types of links, so a device will have different MAC addresses for Wi-Fi, Bluetooth, etc.&lt;&#x2F;p&gt;
&lt;p&gt;Hosts can then interact in multiple ways. One way is &lt;em&gt;access point&lt;&#x2F;em&gt;. Hosts must communicate with an access point which acts as an intermediary between hosts. Another is &lt;em&gt;ad hoc&lt;&#x2F;em&gt;. When you set up your Amazon Echo for the first time, you connect with it ad hoc via Bluetooth on your app and set it up from there to program it. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;arp&quot;&gt;ARP&lt;&#x2F;h2&gt;
&lt;p&gt;When connecting via LAN, hosts are part of the same subnet. In order to translate the IP address to a MAC address, the hosts use a protocol called &lt;strong&gt;ARP (Address Resolution Protocol&lt;&#x2F;strong&gt;. This is a simple protocol which defines its own identification and a source&#x2F;destination address, as well as a broadcast &lt;code&gt;FF&lt;&#x2F;code&gt; packet. We know the sender IP, MAC, and the destination IP, but we don&#x27;t know the destination MAC address, so that field is blank. The ARP packet will traverse the entire link, and if a host recognizes its own IP address, then it will send an ARP reply back to the source with its MAC address.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lan-extension&quot;&gt;LAN Extension&lt;&#x2F;h2&gt;
&lt;p&gt;LANs seem pretty nice. Why don&#x27;t we just use LANs everywhere? Bandwidth is limited, so you need to limit the amount of hosts that can connect on one network.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;em&gt;learning bridge&lt;&#x2F;em&gt; is a type of access point that connects LAN segments. It maintains a table of hosts that are connected to the network. It intermediates between the hosts, receiving and sending packets as necessary if packets are sent between LANs. For each packet, the bridge stores the MAC and port of the packet and then floods all the LANs if it can&#x27;t find a match.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;multiple-access&quot;&gt;Multiple Access&lt;&#x2F;h2&gt;
&lt;p&gt;If two packets are sent at the same time, that is called &lt;em&gt;collision&lt;&#x2F;em&gt; or &lt;em&gt;interference&lt;&#x2F;em&gt;. We can only have one pair communicating at a time. We must have a multiple access protocol to make sure that only one access method is used at a time. You can think of being in a class; if everyone spoke at once, it would be mayhem! There must be an extra overhead of each person raising their hand in order to ensure correct communication takes place.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wireless&quot;&gt;Wireless&lt;&#x2F;h2&gt;
&lt;p&gt;When a host sends a wireless signal that bounces off of a satellite to a receiver, how do we know that interference has occurred? We could use a TCP packet timeout, but that takes a while. A neat trick that you can do is leverage the fact that satellites reflect all signals to everyone, including your own. A host can receive its own signal and check if it was interfered with.&lt;&#x2F;p&gt;
&lt;p&gt;Originally, &lt;strong&gt;pure ALOHA&lt;&#x2F;strong&gt; was used, based on the needs of a university in Hawaii. This uses the broadcast method. If it receives garbage back, it will sleep for a random amount of time and retransmit. The reason it is random is because if both the hosts that sent garbage data send the packets again at the same time, it will cause &lt;em&gt;another&lt;&#x2F;em&gt; collision! For transmission time \(t\), the vulnerable period where packets will be destroyed is \(2t\).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Slotted ALOHA&lt;&#x2F;strong&gt; has better checks to stop collisions from occurring in the first place by setting slots where hosts will send packets, which means that they wouldn&#x27;t collide in different slots.&lt;&#x2F;p&gt;
&lt;p&gt;But the best throughput is done if we check the actual channel before transmitting the packet, so we don&#x27;t have to guess or check after the fact if a collision happened. For this we need &lt;strong&gt;CSMA (Carrier Sense Multiple Access)&lt;&#x2F;strong&gt;. If the channel is sensed and there are packets travelling, the host will wait to send the packet then immediately send a packet when free. This is a persistent system. The problem with this is that this will cause a collision when multiple hosts are waiting for a channel. We can solve this the way we solved ALOHA. If each host sleeps a random amount of time, even a small amount of time, it will give the hosts time to sense the channel.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;contention-access-methods&quot;&gt;Contention Access Methods&lt;&#x2F;h2&gt;
&lt;p&gt;In order to sense the channel, there are many methods.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;1-Persistent CSMA&lt;&#x2F;strong&gt; will constantly bug the channel to check if the channel is idle. If it&#x27;s busy, transmit and check again. This only really works when there is one host trying to connect.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Non-Persistent CSMA&lt;&#x2F;strong&gt; will transmit, then sleep for a random amount of time before trying again if the channel is busy. This means that that collisions won&#x27;t happen. This is better than the previous method, but can be slow.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;\(P\)-Persistent CSMA&lt;&#x2F;strong&gt; has the same idea, but instead of being random it will transmit again with probability \(P\). This fine-tunes the previous method for our specific needs and improves utilization.&lt;&#x2F;p&gt;
&lt;p&gt;Ethernet uses the &lt;strong&gt;Ethernet Backoff Algorithm&lt;&#x2F;strong&gt;, which utilizes binary exponential backoff. If a collision happens, then it will pick a time slot to transmit again out of \(2^k\) slots, where \(k\) is the number of collisions that have occurred. The length of each time slot is equivalent to. For example, let&#x27;s say two hosts collide on an Ethernet connection. Both hosts will both, on their own, divide the next few seconds into two slots and randomly pick between them. If they each end up in different slots, they&#x27;ll transmit fine. If they end up in the same slot again, repeat the process but with four slots. As you can see, the chance of collision will dramatically decrease with more slots. After a maximum of sixteen slots, if there are still collisions, then your host will give up and say that the link is down.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ethernet&quot;&gt;Ethernet&lt;&#x2F;h2&gt;
&lt;p&gt;Ethernet is a wired multiple access protocol defined by IEEE 802.3. As previously stated, it uses 1-persistent CSMA with the backoff algorithm.&lt;&#x2F;p&gt;
&lt;p&gt;Ethernet frames have a preamble full of special information, as well as the source&#x2F;destination MAC addresses already mentioned. The header will also say the type of protocol being used, whether it is IPv4, IPv6, ARP, RARP, etc. Finally, at the end, a checksum will be stored so that we can check if corruption has occurred.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Preamble&lt;&#x2F;th&gt;&lt;th&gt;Source MAC&lt;&#x2F;th&gt;&lt;th&gt;Dest. MAC&lt;&#x2F;th&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;th&gt;Data&lt;&#x2F;th&gt;&lt;th&gt;Checksum&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;multiple-access-channel-partitioning&quot;&gt;Multiple Access Channel Partitioning&lt;&#x2F;h2&gt;
&lt;p&gt;We have previously assumed that all hosts are fighting for the use of one channel and will have to retry connections if collisions occur. One way to solve this is to have predetermined allocation of channel access. This way, there is no chance of collision because each user will wait its turn on its own. However, this can introduce wastage if users are assigned to a channel partition but end up being idle. The division is governed by different techniques.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;TDMA (Time Division Multiple Access)&lt;&#x2F;strong&gt; will divide the spectrum across time. Like how OS schedulers will give processes exclusive access to the CPU for a certain amount of time, so too will users be granted exclusive access to the channel for a certain amount of time.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;FDMA (Frequency Division Multiple Access)&lt;&#x2F;strong&gt; will divide the spectrum across frequencies. The most common example of this is for radio. Radio channels are exclusive to certain frequencies.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;CDMA (Code Division Multiple Access)&lt;&#x2F;strong&gt; will send signals in a coded format. Imagine a large group of people that are speaking all at the same time. If everyone is speaking in English, the message will quickly get garbled. However, if every conversation has its own language, then the message will be clear. Even if I hear a conversation next to me in Chinese, I will tune it out because I don&#x27;t know Chinese and be able to speak and hear in English. There must be some amount of power control so that one person does not speak too loud, but otherwise the communication will work.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lan&quot;&gt;LAN&lt;&#x2F;h2&gt;
&lt;p&gt;Computers can be connected through a sort of wireless LAN. If connecting a computer that does not have a screen or an otherwise easily accessible user interface, it is often convenient to connect with it using ad-hoc mode to a device with a screen so it can be configured, like Amazon Echo.&lt;&#x2F;p&gt;
&lt;p&gt;Each local set of computers that can connect in these ways is known as a &lt;strong&gt;BSS (Basic Service Set)&lt;&#x2F;strong&gt;. This is known commonly as a &lt;strong&gt;LAN&lt;&#x2F;strong&gt;. The sender will wait for the sense channel to be idle than transmit the entire frame, else do a random timeout multiplying by 2 as with Ethernet, and the access point will return an ACK.&lt;&#x2F;p&gt;
&lt;p&gt;Access control in this sense is mediated by the time waited to check if the channel is busy or not. However, this can still cause collisions if a router does not hear from another, which is the &lt;strong&gt;hidden terminal problem&lt;&#x2F;strong&gt;. An &lt;strong&gt;exposed terminal problem&lt;&#x2F;strong&gt; may occur when a terminal is not properly signaled to not send because it is busy.&lt;&#x2F;p&gt;
&lt;p&gt;In order to mediate these issues, senders send a small packet called &lt;strong&gt;RTS (request to send)&lt;&#x2F;strong&gt; and a receiver will send a small packet called &lt;strong&gt;CTS (clear to send)&lt;&#x2F;strong&gt;. If senders hear an RTS from somewhere else, they&#x27;ll wait until the receiver is clear to send to. If there isn&#x27;t a CTS, they can transmit because the receiver is open in that time. In this context, the HTP and ETP are caused when neither RTS nor CTS are heard, or when RTS is heard but not CTS.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid these issues, we can reserve channels in the same way that channels are reserved in CSMA. The small reservation packets are unlikely to collide compared to the large frame packets.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bluetooth&quot;&gt;Bluetooth&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Bluetooth&lt;&#x2F;strong&gt; is a short-range kind of Wi-Fi technology that operates in the ISM band of 2.4GHz to 2.8 GHz. It was initially created for use by wireless mice and keyboards. The data rate goes up to 721 Kbps, which is fine because it&#x27;s not intended for data transfer, just communicating with nearby wireless devices.&lt;&#x2F;p&gt;
&lt;p&gt;In order to code this message, &lt;strong&gt;frequency hopping will be used&lt;&#x2F;strong&gt;. A frequency sequence will be sent via CDMA about which frequencies will be used to transmit data in sequence. Then, the sender will send the sequence in parts at each frequency in order. The receiver which knows the frequency sequence will be able to tune into the right frequencies at the right time and receive the correct bitstream. Anyone else listening to the bitstream that doesn&#x27;t know the frequency sequence won&#x27;t understand it.&lt;&#x2F;p&gt;
&lt;p&gt;Personal area networks under Bluetooth are either &lt;strong&gt;Piconet&lt;&#x2F;strong&gt; or &lt;strong&gt;Scatternet&lt;&#x2F;strong&gt;. Piconet has master&#x2F;slave nodes, where the master is the one that allocates the Bluetooth channels among the slaves. Scatternet allows devices to be either master or slave in different networks so that a device can act differently in Bluetooth in different settings.&lt;&#x2F;p&gt;
&lt;p&gt;Connection is established by beginning with an inquiry broadcast by the Bluetooth device. A potential slave will respond and the master will send back a page for the hopping sequence. The other device will establish itself as a slave through a slave response and the master device will do likewise, at which time the connection is established through ACK-DAC.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Routing Algorithms</title>
		<published>2022-03-21T00:00:00+00:00</published>
		<updated>2022-03-21T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/routing-algorithms/" type="text/html"/>
		<id>https://sharifhsn.github.io/routing-algorithms/</id>
		<content type="html">&lt;p&gt;When a host needs to find the best destination&#x2F;prefix to another host, what &lt;strong&gt;routing algorithm&lt;&#x2F;strong&gt; does it use? We can use either &lt;em&gt;intra&lt;&#x2F;em&gt; or &lt;em&gt;inter&lt;&#x2F;em&gt; domain.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;routing-and-forwarding&quot;&gt;Routing and Forwarding&lt;&#x2F;h2&gt;
&lt;p&gt;As you may recall, the &lt;em&gt;routing table&lt;&#x2F;em&gt; is a large DRAM table containing all possible paths and the &lt;em&gt;forwarding table&lt;&#x2F;em&gt; is a small SRAM table containing only the best possible path. The router also caches previous best paths so that they don&#x27;t need to be retrieved for the same host over and over from DRAM.&lt;&#x2F;p&gt;
&lt;p&gt;You can visualize multiple routers in an undirected weighted graph. The weights matter so that a slow link will not be chosen even if the path is technically slower. By maintaining all paths, the router can pick a new best path if a link in the route crashes.&lt;&#x2F;p&gt;
&lt;p&gt;But how does the router actually update the forwarding table? There are several different algorithms we can use.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;link-state&quot;&gt;Link State&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Link state&lt;&#x2F;strong&gt; is an intra-domain method that works fine for 50-100 routers, say on a university campus.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s use the graph analogy again. It is often useful to abstract concepts in networking to graphs when thinking about algorithms, since we can apply well-known concepts from mathematics and algorithm design to the problem. There are multiple factors that play into the weight of each link, not just link speed, but routers assign their own holistic score to links for simplicity.&lt;&#x2F;p&gt;
&lt;p&gt;The obvious choice here is to use &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dijkstra%27s_algorithm&quot;&gt;Dijkstra&#x27;s algorithm&lt;&#x2F;a&gt; for shortest path, as it applies to undirected weighted graphs like the on we have just constructed. This algorithm generates the shortest path to every path up to and including the destination. It requires knowing all of the link speeds beforehand. This is accomplished through a &lt;em&gt;link state broadcast&lt;&#x2F;em&gt; i.e. pinging every router and checking the link speed of the ping. The algorithm is also iterative, which means the number of shortest destinations scales with iterations linearly. The time complexity of the algorithm is \(Θ(|E| + |V| \log |V|)\).&lt;&#x2F;p&gt;
&lt;p&gt;This algorithm works best in a centralized graph like at a university. Instead of sending a link state broadcast every time a connection is made, each node in a graph will send its own &lt;strong&gt;link state&lt;&#x2F;strong&gt; to a centralized location, and that location will be checked for recomputation of shortest path.&lt;&#x2F;p&gt;
&lt;p&gt;The centralized node is the one that does all the calculations for shortest path. This is known as a &lt;strong&gt;distance vector&lt;&#x2F;strong&gt;. Each router must calculate its own distance on top of the other links to the node that it must pass by. Think of a table that is passed from link to link which is updated according to Dijkstra&#x27;s algorithm. The initial distance vector table for a router only contains the link speeds for its adjacent routers, and all others are marked as infinity. Degenerate longer paths are thrown out when tables &amp;quot;merge&amp;quot; at a router.&lt;&#x2F;p&gt;
&lt;p&gt;If a link breaks, then the routers that have broken links get reset in the final table. When the broken router sends a new distance vector table, it updates the central table in the same process as the table generation.&lt;&#x2F;p&gt;
&lt;p&gt;However, this doesn&#x27;t work well when we have different domains in different autonomous systems controlled by different ISPs. We need some kind of inter-AS algorithm to manage this. However, as the intra-AS algorithms works well, we use &lt;em&gt;federation&lt;&#x2F;em&gt; in our algorithms. Inter-AS algorithms are used to route between ASes and intra-AS algorithms are then used within the AS.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bgp&quot;&gt;BGP&lt;&#x2F;h2&gt;
&lt;p&gt;There are some barriers to inter-AS routing. We might not know whether the host is reachable, so we need to ask nearby ASes if they know. The protocol that these ASes use is &lt;strong&gt;BGP&lt;&#x2F;strong&gt;, the &lt;strong&gt;Border Gateway Protocol&lt;&#x2F;strong&gt;. With BGP, ASes can&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;obtain subnet reachability information from neighboring ASes&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;propagate reachability information to all the routers within the AS&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;use this information to calculate the best route to another subnet&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;BGP works through persistent sessions between BGP routers over semi-permanent TCP connections. The sessions can be through any router, there doesn&#x27;t need to be a physical link. The two peers can communicate regardless of the physical router.  This is the sequence of steps:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Establish TCP over port 179.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Exchange routing tables. At first, this is a lot of data, but after a connection is established only deltas (like Git) need to be exchanged.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Send four kinds of messages.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Open&lt;&#x2F;em&gt; - establish session by exchanging AS numbers and the BGP identifier (arbitrary router IP address). There is a timer for how long to wait before just assuming the session is down i.e. in an outage.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Notification&lt;&#x2F;em&gt; - report unusual conditions, usually an error. If there are header errors, or a timer has expired, etc. then the TCP session must be terminated.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Update&lt;&#x2F;em&gt; - inform if there are new active or old inactive routers. The message includes the withdrawn routes, which are inactive routers, the length of that field as it can be variable, etc.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Keepalive&lt;&#x2F;em&gt; - regular message that the session is alive. BGP needs this regular message otherwise the neighbor AS won&#x27;t know whether you&#x27;re alive or not.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;When we say that a router is advertising a prefix, there are some necessary assumptions. The routing information must be valid, and does not need to be refreshed until necessary. The path that an AS advertises to a node is the same path that AS uses to communicate with that node.&lt;&#x2F;p&gt;
&lt;p&gt;The BGP protocol additionally has many attributes that indicate the characteristics of a prefix:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ORIGIN: advertises the origin of an announcement and prefix injection. This is manually configured by intra-routing protocols.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;AS_PATH: a link of ASes which is the path of ASes that the prefix has traveled to. This is useful for detecting loops and selecting shorter routes of ASes.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;NEXT_HOP: the hop field is when you cross the AS boundary. After you cross, the next hop value is the next AS you need to get to in order to get to the destination router. The reason this is important is because the IP packets within an AS can travel in any order irrespective of BGP, so the intra-routing algorithm can decide where to go based on this value. This becomes significant when a network experiences &lt;em&gt;transit traffic&lt;&#x2F;em&gt; and different networks are using that network as an intermediary. In order to get the packet to exit the network as quickly as possible, BGP can make the decision to send the packet through non-BGP routers if it&#x27;s a faster way to make the packet leave the network.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;MED: stands for Multi-Exit Discriminator. If ASes are connected via multiple links, the AS that receives a prefix uses this value to discriminate between exits, with a lower value being better.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;LOCAL_PREF: indicates a local preference for a specific prefix, is a number that is more for more preference, by default 100. For example, if outbound traffic is preferred to be a specific exit point, then that point will have high local preference. It can be used to break a tie between routers.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Routers</title>
		<published>2022-03-10T00:00:00+00:00</published>
		<updated>2022-03-10T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/routers/" type="text/html"/>
		<id>https://sharifhsn.github.io/routers/</id>
		<content type="html">&lt;p&gt;Everyone nowadays gets the Internet through the &lt;strong&gt;router&lt;&#x2F;strong&gt; in their home. But what &lt;em&gt;is&lt;&#x2F;em&gt; a router?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;speed&quot;&gt;Speed&lt;&#x2F;h2&gt;
&lt;p&gt;It&#x27;s likely that you have an internet speed in the tens of Mbps. This unit is &lt;strong&gt;megabits per second&lt;&#x2F;strong&gt;, or one million bits per second. Some routers in important locations have speeds in the Gbps, which is 1 &lt;em&gt;billion&lt;&#x2F;em&gt; bits per second. This is incredibly quick. How do routers accomplish this?&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structure&quot;&gt;Structure&lt;&#x2F;h2&gt;
&lt;p&gt;The router is composed of a &lt;strong&gt;control plane&lt;&#x2F;strong&gt; and a &lt;strong&gt;data path&lt;&#x2F;strong&gt;. The control plane contains all the necessary external tooling to determine the paths. It contains routing protocols that need to be implemented, as well as a routing table. This table is used to look up all the possible paths to the destination and pick the shortest one.&lt;&#x2F;p&gt;
&lt;p&gt;This information is all stored on the data path, where each packet is actually processed. The routing table shortest path is put into the &lt;strong&gt;forwarding table&lt;&#x2F;strong&gt; which typically has a very small amount of SRAM in order to quickly mediate routing. You can think of it almost like a register that is close the process as opposed to the main memory where the calculations are made.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Remember this distinction! The &lt;em&gt;routing table&lt;&#x2F;em&gt; contains all possible routes from this router, kind of like Google Maps. It needs to be a big table, so it is usually stored in slow, inexpensive DRAM. The &lt;em&gt;forwarding table&lt;&#x2F;em&gt; only contains the best possible route, so it is a small table stored in fast, expensive SRAM.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Routers must also have input and output buffers. The input buffer is needed because the router may take in packets faster than it can process them, so it needs a place to put them before it can figure them out. The output buffer is needed because of the opposite problem; if the router processes the packets faster than the output link can output them, the packets need a place to be.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;forwarding-engine&quot;&gt;Forwarding Engine&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s examine the forwarding table in a little more detail. The forwarding table is a simple table that looks like this:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Dest-network&lt;&#x2F;th&gt;&lt;th&gt;Port&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;65.0.0.0&#x2F;8&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;128.9.0.0&#x2F;16&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;149.12.0.0&#x2F;19&lt;&#x2F;td&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;It is a simple path from networks, remembering which port to send packets.&lt;&#x2F;p&gt;
&lt;p&gt;You might have noticed that our destination networks are in prefix form. The one on port 7 has the longest prefix because it is matching the first 24 bits. We must match the longest prefix form first when looking for the network. These prefixes are the most specific and therefore must be matched before the smaller, more general prefixes. Prefixes can overlap, so we must pick the more specific one. It is typically not explicitly linear, a hash table-like structure is used to make lookups faster.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, &lt;strong&gt;hierarchical addressing&lt;&#x2F;strong&gt; is important for allowing us to aggregate routes. Different organizations within the same ISP network will have some bits after the network bits devoted to differentiating between organizations. Let&#x27;s imagine that Rutgers Newark and NJIT are on the same ISP network, but are different organizations, obviously. The first 19 bits of that prefix might be devoted to the ISP network, then the next 4 bits will be used for organizations within that network.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;switching-fabrics&quot;&gt;Switching Fabrics&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s consider each port as form of input and output. We will need a way to switch between devices. There are multiple ways to implement &lt;strong&gt;switching fabrics&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;One way is through &lt;strong&gt;memory&lt;&#x2F;strong&gt;. This is the cheapest way of going about it. The I&#x2F;O device will take the network and write it into memory. We can use DMA (Direct Memory Access) to do this more quickly. The header is processed, and the router checks the routing table for the best route. The packet must be copied from the port into memory, then processed, then loaded back into the output port. This is very slow. Most of the bottleneck is in the memory bus when copying memory. These routers are typically less than 10 Mbps.&lt;&#x2F;p&gt;
&lt;p&gt;Another way is through &lt;strong&gt;bus&lt;&#x2F;strong&gt;. The packet is transferred between input and output through a I&#x2F;O bus, with a memory buffer to hold the packet on each end. There&#x27;s no CPU movement here, it&#x27;s all I&#x2F;O instructions. But we still need some kind of command for the destination port number. The CPU will periodically calculate and &lt;em&gt;cache&lt;&#x2F;em&gt; the forwarding table on the input device (also known as &lt;strong&gt;line card&lt;&#x2F;strong&gt;). If there is a cache miss, then I&#x2F;O will ask the CPU to update the cache from main memory, which is slow but doesn&#x27;t happen often. However, since there&#x27;s only one bus, there is only one communication possible between one port and another at a time. This speed is in the high Mbps.&lt;&#x2F;p&gt;
&lt;p&gt;The third way, which is the most high-end way, is the &lt;strong&gt;crossbar&lt;&#x2F;strong&gt;. It works like a bus, except that there exists a bus between every single port, which means that for \(n\) ports, we can have \(\frac{n}{2}\) simultanenous transfers. This is in the best-case scenario where each input goes to a different output. However, if two ports are trying to connect to the same port, then one of them will be bottlenecked because it&#x27;s still one bus. However, this complicated switching fabric is extremely expensive, which scales with the number of ports. The price can be worth it for a company like Google; their speeds can be in the Tbps!&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>More Internet Protocols</title>
		<published>2022-03-03T00:00:00+00:00</published>
		<updated>2022-03-03T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/other-protocols/" type="text/html"/>
		<id>https://sharifhsn.github.io/other-protocols/</id>
		<content type="html">&lt;p&gt;Besides the primary Internet protocols, there are some others to learn about, like &lt;strong&gt;DHCP&lt;&#x2F;strong&gt;, &lt;strong&gt;NAT&lt;&#x2F;strong&gt;, &lt;strong&gt;IPv6&lt;&#x2F;strong&gt;, etc.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;dhcp&quot;&gt;DHCP&lt;&#x2F;h2&gt;
&lt;p&gt;What happens if a device doesn&#x27;t have a permanent IP address? You take your phone around multiple mobile networks, there isn&#x27;t a consistent IP address between them. How do you access the internet without an IP address?&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic Host Configuration Protocol&lt;&#x2F;strong&gt; is a client-server protocol that is used in these scenarios. As the name implies, it allows for dynamic IP address allocation that are leased for a certain amount of time. Configuring things like the subnet mask, gateway configuration, etc. to set up an IP is complicated and not feasible for the average user. Imagine if you had to do all that setup everytime your phone moved to a new location!&lt;&#x2F;p&gt;
&lt;p&gt;DHCP has two main components: the protocol for delivering the bootstrapping information from the server to clients, and the algorithm for dynamically assigning addresses to new clients. How do you start a connection from nothing?&lt;&#x2F;p&gt;
&lt;p&gt;In order to allocate a new address, there are three modes. Automatic allocation gives permanent address, dynamic allocation leases addresses, and manual allocation is managed by a system administrator.&lt;&#x2F;p&gt;
&lt;p&gt;DHCP sends packets over a socket at port 67. Its IPv4 header indicates that it is protocol 17. The UDP packet is sent with no initial IP address because there is none. It is sent with the broadcast server IP address &lt;code&gt;255.255.255.255&lt;&#x2F;code&gt;. The protocol must also interface with the link layer at the client&#x27;s MAC address; remember, we&#x27;re starting at zero. There is also space for the server hostname, boot filename, and several kinds of options.&lt;&#x2F;p&gt;
&lt;p&gt;The options indicate what the purpose of the UDP packet is. For example, option 1 is &lt;code&gt;DHCPDISCOVER&lt;&#x2F;code&gt;, which is the message that lets the server know that a client is looking for an IP address. The communication sequence is directly encoded into the options in the packet. Some others:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DHCP Offer: server response with parameter proposal&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;DHCP Request: like discover, but focused to a specific server&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;DHCP ACK: server gives IP address to client&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;DHCP NAK: server declines to give IP address to client&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;DHCP Decline: client declines the given IP address&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;DHCP Release: client gives up its IP address&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;DHCP typically applies within a subnet. Relay agents on routers, like with BOOTP, allow servers to handle requests from other subnets.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;nat&quot;&gt;NAT&lt;&#x2F;h2&gt;
&lt;p&gt;There are two kinds of IP addresses: &lt;em&gt;public&lt;&#x2F;em&gt; and &lt;em&gt;private&lt;&#x2F;em&gt;. Private addresses are reserved for &lt;code&gt;10.0.0.0&lt;&#x2F;code&gt; to &lt;code&gt;10.255.255.255&lt;&#x2F;code&gt;. If you send a request to private address, your router will not send it out to the Internet. Private addresses are also free; you can hand out as many as you want without it costing anything.&lt;&#x2F;p&gt;
&lt;p&gt;However, requests sent from a private IP address cannot access the Internet. In order to access the Internet, we use a &lt;strong&gt;Network Address Translation&lt;&#x2F;strong&gt; box. This NAT box is assigned a single public IP address and it is the public-facing IP for all of the machines with private addresses on it.&lt;&#x2F;p&gt;
&lt;p&gt;This is likely how your home router works. Each device in your home only has a private address and every time it sends a request to the Internet, that request is sent to the NAT box in your router and translated to one single public IP for all of the machines in your house.&lt;&#x2F;p&gt;
&lt;p&gt;The NAT box will take in packets that are sent from private IP addresses and record the packet address in a table, then replace the IP address with its own and its port with some random port. When packets are sent back to that address, the NAT box consults its table and sends the packets back to the correct private IP address based on the port it was sent on.&lt;&#x2F;p&gt;
&lt;p&gt;Although there are technically \( 2 ^ {24} \) addresses, in practice you can only have less than \( 2 ^ {16} \) addresses because each of those needs to have an associated port, and that&#x27;s a 16-bit number (minus some reserved ports).&lt;&#x2F;p&gt;
&lt;p&gt;But why would you do this? Remember that IPv4 is a 32-bit number for addresses, which only allow for ~ 4 billion unique devices. Clearly, there will be, and perhaps already are, more devices that use the Internet than that. IPv6 was created in part to solve that problem, but as many devices only accept IPv4, this works in the meantime. It also provides security to users since ports aren&#x27;t accessible from the public, they are instead randomly assigned. Even if someone&#x27;s IP address is tracked, the malicious agent still doesn&#x27;t necessarily know what device the request is from.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ipv6&quot;&gt;IPv6&lt;&#x2F;h2&gt;
&lt;p&gt;IPv6 is an updated protocol from IPv4 that is optimized for the needs of the modern day. It is significantly simplified compared to IPv4 as much of the machinery in an IPv4 header relates to problems that generally no longer exist. However, the header size is also 40 bytes, twice as large as the IPv4 header. This is because the new source and destination IP address that must be stored in the header are now 16 bytes, not 4, the vast majority of the header size is dominated by address size.&lt;&#x2F;p&gt;
&lt;p&gt;IPv6 does not protect against some problems that still exists, such as bit flips. If that happens, the packet is simply dropped because a different layer will do a checksum.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Version&lt;&#x2F;th&gt;&lt;th&gt;Traffic Class&lt;&#x2F;th&gt;&lt;th&gt;Traffic Class&lt;&#x2F;th&gt;&lt;th&gt;Flow Label&lt;&#x2F;th&gt;&lt;th&gt;Flow Label&lt;&#x2F;th&gt;&lt;th&gt;Flow Label&lt;&#x2F;th&gt;&lt;th&gt;Flow Label&lt;&#x2F;th&gt;&lt;th&gt;Flow Label&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Payload Length&lt;&#x2F;td&gt;&lt;td&gt;Payload Length&lt;&#x2F;td&gt;&lt;td&gt;Payload Length&lt;&#x2F;td&gt;&lt;td&gt;Payload Length&lt;&#x2F;td&gt;&lt;td&gt;Next Header&lt;&#x2F;td&gt;&lt;td&gt;Next Header&lt;&#x2F;td&gt;&lt;td&gt;Hop Limit&lt;&#x2F;td&gt;&lt;td&gt;Hop Limit&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;followed by the source address and destination address, along 4-bit boundaries&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>ISP Addressing</title>
		<published>2022-02-28T00:00:00+00:00</published>
		<updated>2022-02-28T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/isp-addressing/" type="text/html"/>
		<id>https://sharifhsn.github.io/isp-addressing/</id>
		<content type="html">&lt;p&gt;How does an ISP assign IP addresses to its customers?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;An ISP has a block of addresses that are partitioned to its customers. If an ISP network has an address like &lt;code&gt;200.8.4&#x2F;24&lt;&#x2F;code&gt; address, that is 256 addresses. &lt;code&gt;&#x2F;20&lt;&#x2F;code&gt; is for 4K hosts, and &lt;code&gt;&#x2F;16&lt;&#x2F;code&gt; is for 64K hosts. In fact, the calculation is \( 2^{32 - n} \).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;subnetting&quot;&gt;Subnetting&lt;&#x2F;h2&gt;
&lt;p&gt;A network can be subdivided into &lt;strong&gt;subnets&lt;&#x2F;strong&gt;. This way you can have each router handling a smaller portion of the network, or have different kinds of routers i.e. wired&#x2F;wireless handling different subnets.&lt;&#x2F;p&gt;
&lt;p&gt;In order to divide IP addresses, we use a &lt;strong&gt;subnet mask&lt;&#x2F;strong&gt;. For example, if our network is &lt;code&gt;128.64.32&#x2F;24&lt;&#x2F;code&gt;, a range we could have is &lt;code&gt;128.64.32.0-127&lt;&#x2F;code&gt; and &lt;code&gt;128-255&lt;&#x2F;code&gt;. The easiest way to mask this is to look at the most significant bit. In the first range, the most significant bit is 0, and in the second range, the most significant bit is 1. The mask in this case would be &lt;code&gt;255.255.255.128&lt;&#x2F;code&gt; or in hex, &lt;code&gt;F.F.F.8&lt;&#x2F;code&gt;. If we bitwise AND this mask with the IP address, we will get the correct subnet.&lt;&#x2F;p&gt;
&lt;p&gt;We can follow the same procedure to get further divisions by the power of 2. We can mask over two bits to get four subnets of ranges &lt;code&gt;0-63&lt;&#x2F;code&gt;, &lt;code&gt;64-127&lt;&#x2F;code&gt;, &lt;code&gt;128-191&lt;&#x2F;code&gt;, and &lt;code&gt;192-255&lt;&#x2F;code&gt; with a mask of &lt;code&gt;255.255.255.192&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s think of an analogy. If we want to deliver some mail to our neighbor, the easiest way to do it is to go directly to his mailbox and give it to him instead of passing it off to the post office. In the same way, we can quickly send messages between hosts on the same subnet.&lt;&#x2F;p&gt;
&lt;p&gt;In order to facilitate this, the router will first check if the sender and destination (both first &amp;amp;ed with the subnet mask) are in the same subnet. If they are, it doesn&#x27;t bother sending the message over the Internet and it will actually just directly send the message to the destination itself.&lt;&#x2F;p&gt;
&lt;p&gt;In particular, this makes email between people on the same networks extremely quick. This is why it&#x27;s nice to have email between people with the &lt;code&gt;scarletmail.rutgers.edu&lt;&#x2F;code&gt; domain.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ipv4-header&quot;&gt;IPv4 Header&lt;&#x2F;h2&gt;
&lt;p&gt;In order to get a packet to a destination host, we need a packet header with the identity of both the destination identity and the source identity. At this layer, we don&#x27;t worry about reliable exchange, dropping packets, sequence numbers, etc. That&#x27;s for TCP to handle, our only job is to send the packet to the destination.&lt;&#x2F;p&gt;
&lt;p&gt;However, we have to detect some kinds of problems. We don&#x27;t want to loop packets over and over, this will overload the network. There used to be a worry of fragmentation, if the size of the packet is greater than the &lt;em&gt;maximum transmission unit&lt;&#x2F;em&gt; (MTU) of the router. Nowadays, everyone has broadband so this is not an issue because everybody has high link speeds. When IPv4 was invented we needed checksums for verification if there are bit flips. IPv6 addresses have much less checksum machinery because it&#x27;s a waste nowadays, it only checks at the end. IPv4 has to calculate a checksum at every router, which catches errors early but is generally wasteful.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;em&gt;time to live&lt;&#x2F;em&gt; (TTL) is 1 byte long and is used to protect against loops. It starts at 255 and decrements every time it passes through a router. If the TTL is 0,  the packet is dropped and a &amp;quot;time exceeded&amp;quot; error is thrown to sender. This prevents the packet from being looped around forever.&lt;&#x2F;p&gt;
&lt;p&gt;An entire 4 bytes is devoted to fragmentation machinery. This is not in IPv6, which simply throw an error if the packet is too large. The reason this is fine because it is a rare case nowadays and it cuts fat out of the header. Here are the steps of fragmentation:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;router receives packet larger than MTU&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;em&gt;Don&#x27;t Fragment&lt;&#x2F;em&gt; (DF) flag is set, throw &lt;em&gt;Fragmentation Needed&lt;&#x2F;em&gt; error&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;else, divide the packet into fragments maximum size &lt;code&gt;outgoing MTU&lt;&#x2F;code&gt; - header size (20 bytes)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;in each new packet fragment, the &lt;code&gt;length&lt;&#x2F;code&gt; field is the size of the fragment, the &lt;em&gt;More Fragments&lt;&#x2F;em&gt; (MF) flag is set except for the last fragment, and the &lt;code&gt;fragment offset&lt;&#x2F;code&gt; field is set to the offset of the fragment in 8-byte blocks. The checksum is recomputed for the fragment. &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;IPv4#Fragmentation_and_reassembly&quot;&gt;IPv4 - Wikipedia&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;icmp&quot;&gt;ICMP&lt;&#x2F;h2&gt;
&lt;p&gt;What do we do to propagate errors? We&#x27;re already using IP for sending messages, how do we send errors? This what the &lt;strong&gt;ICMP&lt;&#x2F;strong&gt; protcol is for. It is unreliable like UDP, and is tightly coupled with the implementation of IP. Its protcol ID is 1, which signifies its importance.&lt;&#x2F;p&gt;
&lt;p&gt;There are certain known error codes. The &lt;em&gt;echo request&#x2F;reply&lt;&#x2F;em&gt; also known as &lt;em&gt;ping&lt;&#x2F;em&gt; is simply a request to check if the host is alive and responding. There is also the &lt;strong&gt;traceroute&lt;&#x2F;strong&gt;, which records the route that a packet takes by tracking TTL. As we know, when a router receives a packet, it decrements TTL. If we start TTL at 0 and slowly increase it, it will throw time exceeded back to us from each router in order. This way, we can see every router on the way to our destination.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>HTTP Explained</title>
		<published>2022-02-20T00:00:00+00:00</published>
		<updated>2022-02-20T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/http/" type="text/html"/>
		<id>https://sharifhsn.github.io/http/</id>
		<content type="html">&lt;p&gt;&lt;strong&gt;HTTP&lt;&#x2F;strong&gt; is probably the most visible Internet protocol to end users. It appears (as well as its cousin, &lt;strong&gt;HTTPS&lt;&#x2F;strong&gt;) at the beginning of every URL we use to access the internet. But how does it work?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;HTTP stands for HyperText Transfer Protocol. It defines the structure of messages that are passed between two programs: a &lt;em&gt;client&lt;&#x2F;em&gt; and a &lt;em&gt;server&lt;&#x2F;em&gt;. But before we talk about HTTP, let&#x27;s clarify some vocabulary&lt;&#x2F;p&gt;
&lt;h2 id=&quot;web-terminology&quot;&gt;Web Terminology&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;object&lt;&#x2F;strong&gt; - a file that has an associated URL&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Web page&lt;&#x2F;strong&gt; - a document that consists of multiple objects, typically a base HTML file and other objects. The HTML file will reference other objects through a path.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;URL&lt;&#x2F;strong&gt; - address consisting of the following parts:&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;protocol&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;hostname&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;path name&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;http:&#x2F;&#x2F;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;www.someSchool.edu&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&#x2F;someDepartment&#x2F;picture.gif&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Web browser&lt;&#x2F;strong&gt; - an application such as Firefox or Chrome that acts as the client in HTTP&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Web server&lt;&#x2F;strong&gt; - an application such as Apache that acts as the server in HTTP and houses the Web objects in question&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;http-low-level&quot;&gt;HTTP Low-Level&lt;&#x2F;h2&gt;
&lt;p&gt;Under the hood, HTTP uses TCP to make a reliable connection between the server and client. The client and server both send requests and receive responses from their respective socket interfaces.&lt;&#x2F;p&gt;
&lt;p&gt;When a file is sent, there is no information that the server inherently remembers about the HTTP connection. Because of this, HTTP is considered a &lt;strong&gt;stateless protocol&lt;&#x2F;strong&gt;. This is not always desirable. Sometimes, websites want to remember clients in order to ease use of a website. We will discuss workarounds later.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;connections&quot;&gt;Connections&lt;&#x2F;h2&gt;
&lt;p&gt;The original HTTP 1.0 protocol was &lt;em&gt;non-persistent&lt;&#x2F;em&gt;. This means that every request made between a client and a server had its own connection that was opened and closed every time a request was made. Here&#x27;s the process:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;A TCP connection is created between the client and server on port 80.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;An HTTP request message is sent from the client to the server through the socket.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The server receives the message, retrieves the object that it is requesting, and sends the response message to the client through the socket.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The server &amp;quot;closes&amp;quot; the TCP connection (TCP will wait until it knows that the client has received the message)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The client receives the message and the connection terminates. It will extract the HTML file from the message and initiate a new request for each object referenced within, repeating these steps as needed.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Clearly, this method is inefficient. We are opening a TCP connection for every single request that is made between the same client and server. This inefficiency is mediated slightly by the ability to open serial TCP connections; typical web browsers open 5 to 10 parallel TCP connections. The response time for each connection is \(2 \cdot RTT + T_{trans}\).&lt;&#x2F;p&gt;
&lt;p&gt;HTTP 1.1 introduced &lt;em&gt;persistent&lt;&#x2F;em&gt; connections. In step 4, the server doesn&#x27;t close the TCP connection after sending the response. The entire Web page is sent over the same TCP connection, and the requests can be pipelined for further performance gains. The connection is typically closed on timeout. HTTP&#x2F;2 further builds on this by interleaving requests and responses in the same connection with a way to preserve ordering on each end.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;message-format&quot;&gt;Message Format&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;http&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;&lt;span&gt;GET &#x2F;http HTTP&#x2F;1.1
&lt;&#x2F;span&gt;&lt;span&gt;Host: sharifhsn.github.io
&lt;&#x2F;span&gt;&lt;span&gt;Connection: close
&lt;&#x2F;span&gt;&lt;span&gt;User-agent: Mozilla&#x2F;5.0
&lt;&#x2F;span&gt;&lt;span&gt;Accept-language: fr
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;Host&lt;&#x2F;code&gt; line is technically unnecessary, since the connection is already established by this point, but it&#x27;s useful for Web proxy caches. The &lt;code&gt;Connection&lt;&#x2F;code&gt; line means this connection should be non-persistent. The &lt;code&gt;User-agent&lt;&#x2F;code&gt; line specifies the &lt;strong&gt;user agent&lt;&#x2F;strong&gt;, which is the browser type that is making the request to the server. This is used so that the server can send different websites to different browsers. &lt;code&gt;Accept-language&lt;&#x2F;code&gt; expresses a preference for content in French if it exists, otherwise give the default. In general, the header lines exist to give information that is necessary for the request.&lt;&#x2F;p&gt;
&lt;p&gt;The HTTP response is different than the request. An example response to this message might be:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;http&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-http &quot;&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;&lt;span&gt;HTTP&#x2F;1.1 200 OK
&lt;&#x2F;span&gt;&lt;span&gt;Connection: close
&lt;&#x2F;span&gt;&lt;span&gt;Date: Tue, 09 Aug 2011 15:44:04 GMT
&lt;&#x2F;span&gt;&lt;span&gt;Server: Apache&#x2F;2.2.3 (CentOS)
&lt;&#x2F;span&gt;&lt;span&gt;Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
&lt;&#x2F;span&gt;&lt;span&gt;Content-Length: 6821
&lt;&#x2F;span&gt;&lt;span&gt;Content-Type: text&#x2F;html
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The status line at the top tells us some similar information, like the protocol we are using. The &lt;code&gt;200 OK&lt;&#x2F;code&gt; is our status code for a good response. There are other status codes:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;200 OK: request succeeded, information returned.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;301 Moved Permanently: the address is moved, for example when a website links to its www address; there will be a location header telling the client where the new place is to go&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;400 Bad Request: request is written poorly and could not be understood&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;505 HTTP Version Not Supported: self-explanatory lol&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There&#x27;s tons of valid header lines we can use. The HTTP specification allows for many header lines to be used from various software. Writing a correct HTTP implementation isn&#x27;t easy.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cookies&quot;&gt;Cookies&lt;&#x2F;h2&gt;
&lt;p&gt;I mentioned before that HTTP is stateless, which means that the server does not preserve any information about the client after the connection ends. However, websites really want ways to identify users for operations such as logins. In order to facilitate state, websites use &lt;strong&gt;cookies&lt;&#x2F;strong&gt;. You might have heard of them when you log in to a website and it asks you to accept cookies.&lt;&#x2F;p&gt;
&lt;p&gt;The typical creation method of a cookie might look like this:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;A client makes a request to the server for the first time.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The server generates an identification number for the client.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The server sends a HTTP response to the client with a cookie in the header: &lt;code&gt;Set-cookie: 1678&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The client browser stores the cookie in a special file and sends a request to the server with the same cookie number.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Now, whenever the client requests the server, it will include a cookie in the header which the server will use.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;caching&quot;&gt;Caching&lt;&#x2F;h2&gt;
&lt;p&gt;You might have heard of a &lt;strong&gt;proxy server&lt;&#x2F;strong&gt; before. These servers are usually used by ISPs like your home ISP and your university ISP. These servers contain frequently-accessed data from several origin servers and are located much more closely to the client.&lt;&#x2F;p&gt;
&lt;p&gt;These servers are extremely helpful in improving response times for the client as well as reducing traffic for the server. The close location and LAN nature of proxy servers mean that the request&#x2F;response time between clients and servers are quick. And since the origin server is not accessed as often, its burden of traffic is significantly reduced.&lt;&#x2F;p&gt;
&lt;p&gt;The delay in fetching a response from the Internet tends to be dominated by the time for the institutional server receiving a response from the Internet. However, if there is heavy traffic on the &lt;em&gt;access link&lt;&#x2F;em&gt; between the institutional server and the Internet router, that can slow down speeds to minutes per request, which is obviously unacceptable.&lt;&#x2F;p&gt;
&lt;p&gt;$$ requestRate \cdot requestSize &#x2F; speed = trafficIntensity $$&lt;&#x2F;p&gt;
&lt;p&gt;The intensity between client and LAN is usually negligible, but the access link between LAN and Internet dominates. With a Web cache, hit rate is generally between 0.2 and 0.7.&lt;&#x2F;p&gt;
&lt;p&gt;$$ cacheHit \cdot LANspeed + (1 - cacheHit) \cdot internetSpeed$$&lt;&#x2F;p&gt;
&lt;p&gt;The traffic intensity stops being an issue and Internet delay dominates again once a cache is introduced. It&#x27;s less expensive and faster than increasing access link speed.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>TCP Explained</title>
		<published>2022-02-20T00:00:00+00:00</published>
		<updated>2022-02-20T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/tcp/" type="text/html"/>
		<id>https://sharifhsn.github.io/tcp/</id>
		<content type="html">&lt;p&gt;TCP is the well-known protocol for reliable transfer of data. But how does it actually work?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;&lt;strong&gt;System of handshakes ensures reliable transmission of data.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;What happens if a packet is corrupted, and its bits are flipped?&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Use a checksum for each packet.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;What happens if a packet is lost somewhere?&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Wait for acknowledgement from receiver, and if not received, resend.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;What happens if a packet is duplicated? etc. etc.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There are lots of problems that can happen with UDP. Let&#x27;s create a protocol that doesn&#x27;t have this unreliability.&lt;&#x2F;p&gt;
&lt;p&gt;Our new protocol has a sequence number for each packet, either 0 or 1. This is known as an &lt;em&gt;alternating bit protocol&lt;&#x2F;em&gt;. When it sends a packet, it waits for ACK (acknowledgment) before it sends the next packet. This will take one RTT (round trip transmission) per packet. This is obviously pretty inefficient, but it does solve at least some of these issues. It solves the duplicate issue because if it sends the same packet, it will have the same bit sequence number and hterefore will not be taken into account. You can think of this as an infinite loop which flips its break condition after being broken. This is possible because you&#x27;re only sending one packet at a time. Here is time and utilization.&lt;&#x2F;p&gt;
&lt;p&gt;$$ T_{transmit} = \frac{L_{packetLength}}{R_{transmissionRate}} $$&lt;&#x2F;p&gt;
&lt;p&gt;$$ U_{sender} = \frac{\frac{L}{R}}{RTT - \frac{L}{R}} $$&lt;&#x2F;p&gt;
&lt;p&gt;If we can send W packets at aa time, then we can replace $\frac{L}{R}$ with \(W\), which will improve our time by a factor of \(W\)! However, if we send a stream of packets, then there are more issues. If you send a receiver too much data, then it will throw out the data it cannot receive. If packets get lost somewhere in the router, you will have no idea. Stopping the stream to check for issues wastes a lot of time.&lt;&#x2F;p&gt;
&lt;p&gt;We can solve this using a window time. We send packets up until the first ACK is received, then we check for any problems with ACK. But what is the window size?&lt;&#x2F;p&gt;
&lt;p&gt;$$ B \cdot RTT = W \cdot packetSize $$&lt;&#x2F;p&gt;
&lt;p&gt;This way we can pipeline as many packets as are possible before anything can go wrong. This increases the complexity on the recv side, but keeps the connection simple and reliable. Let&#x27;s say the window size is 3. We can send 3 packets, then we must wait for ACK for the first packet. When the ACK is received for packet p, we send packet p + 3. If the timer expires, we have to resend the packet. We can make the assumption that everything to the left of the window has been ACKed, and everything to the right of the window has not yet been sent.&lt;&#x2F;p&gt;
&lt;p&gt;What is the efficiency of this new method?&lt;&#x2F;p&gt;
&lt;p&gt;$$ U_{sender} = \frac{3 \cdot \frac{L}{R}}{RTT \cdot \frac{L}{R}} $$&lt;&#x2F;p&gt;
&lt;p&gt;This is an increase of a factor of 3!&lt;&#x2F;p&gt;
&lt;p&gt;But what if a packet is dropped and sent later? This is where the receiver comes in. There are two ways of dealing with this:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Go back N: simple, keep a buffer of 1 and throw out data with greater sequence numbers and ACK at that packet that was received. This will force the sender to resend all of the packets thata re now timed out. However, this also throws out correctly received packets.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Selective Repeat: complex, keep a buffer proportional to W and keep data that has been received, cancelling the timers for each. Once the data has been correctly received, you can move the window and keep the buffer open for anything that hasn&#x27;t been received. Let&#x27;s say packet 1 is timed out but 2 and 3 came in correctly. We can cancel those two timers and slide the window to 4 and 5 but still wait for 1. &lt;em&gt;There are only ever W packets in transmission at any given point!&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In order to demonstrate the benefits of selective repeat over go back N, we&#x27;ll work though an example. Say we are sending 5 packets of size 100 B each over a 100 MB&#x2F;s link with a RTT of 100 ms, with packet timeout being send_time + RTT and the window buffer being of size 5. How long would it take to receive all of the packets if we drop the third packet?&lt;&#x2F;p&gt;
&lt;p&gt;The send_time here is 100 B &#x2F; 100 MB&#x2F;s or 0.001 ms. The time to receive a packet is half of RTT or 50 ms. The timeout length is 100.001 ms.&lt;&#x2F;p&gt;
&lt;p&gt;With go back N, packets 1 and 2 are received at times 50.001 ms and 50.002 ms. All good! But when the third packet is dropped, we must wait 100.01 ms to receive it again at 150.003 ms. Even though we received packets 4 and 5 already at 50.004 ms and 50.005 ms, we had to throw them out because we didn&#x27;t get packet 3. We resend them as soon as possible after packet 3 so they are received at 150.004 ms and 150.005 ms respectively. The whole transaction takes 150.005 ms.&lt;&#x2F;p&gt;
&lt;p&gt;With selective repeat, the four non-dropped packets are received in the same way. However, after packet 3 times out and is resent, it is the only packet that is sent at 150.003 ms, since every other packet was within our window. The whole transaction here will take 150.003 ms.&lt;&#x2F;p&gt;
&lt;p&gt;The protocol we have just created is known as &lt;strong&gt;TCP&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;connection management&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;retransmission&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;flow control&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;congestion control&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;frame format&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;It has it all!&lt;&#x2F;p&gt;
&lt;p&gt;TCP is the default protocol for every web browser in existence and is the de facto protocol for reliable transmission. Chrome now also uses QUIC which is a Google-created protocol but the vast majority of Internet traffic is still TCP.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tcp-header&quot;&gt;TCP Header&lt;&#x2F;h2&gt;
&lt;p&gt;The TCP header is much more complex than the UDP header. It includes some of the same elements, such as the port numbers and the checksum, and others:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;32-bit sequence number and acknowledgement number, which are used for reliability&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;16-bit receive window for &lt;em&gt;flow control&lt;&#x2F;em&gt; so that the bytes sent do not overwhelm the receiver&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;4-bit header length field to indicate the length of the &lt;em&gt;header&lt;&#x2F;em&gt;, needed because of variable options, but usually 20&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;variable options field needed when specific maximum segment size (MSS) is needed or other options for high-speed networks&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;6-bit flag field: ACK for a segment that is an acknowledgement; RST, SYN, and FIN for connections, PSH for immediate network sending, and URG to indicate some urgent data is located at the location where the 16-bit urgent data pointer points (these last three are typically unused)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The sequence and acknowledgment numbers are how TCP messages are ordered despite being sent in a full-duplex way. The sequence number orders the segments for reconstruction into a full message, and the acknowledgment number is a way of communicating the next byte that the sender needs. This way, if a segment is dropped, the sender of the dropped segment knows that the receiver didn&#x27;t get it because they&#x27;re still waiting on it in the acknowledgement number.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rtt&quot;&gt;RTT&lt;&#x2F;h2&gt;
&lt;p&gt;Round-trip time is an important concept when we consider making our protocol as fast as possible. This is how long it takes for a segment to be sent and an acknowledgment for that segment to be recieved. In order to get an accurate measure of the RTT, TCP takes the current RTT and refines it to an average as more segments are transmitted, since any one SampleRTT (SRTT) might be an outlier. In order to get the average EstimatedRTT we follow this formula:&lt;&#x2F;p&gt;
&lt;p&gt;$$ERTT = (1 - α) \cdot ERTT + α \cdot SRTT$$&lt;&#x2F;p&gt;
&lt;p&gt;\(α\) in this formula is typically 0.125. This means that average is weighted towards recent samples, since they better reflect the current weight.&lt;&#x2F;p&gt;
&lt;p&gt;We should also have a measure of variance in RTT, since averages can be deceiving. DevRTT is the measure of the variance, which is calculated like this:&lt;&#x2F;p&gt;
&lt;p&gt;$$DevRTT = (1 - β) \cdot DevRTT + β \cdot | SampleRTT - EstimatedRTT |$$&lt;&#x2F;p&gt;
&lt;p&gt;Like ERTT, DRTT moves and is weighted recently, with a \(β\) value of usually 0.25.&lt;&#x2F;p&gt;
&lt;p&gt;The reason this is important is because the interval at which a TCP segment transmission times out is based on RTT. TCP calculates this way:&lt;&#x2F;p&gt;
&lt;p&gt;$$TimeoutInterval = ERTT + 4 \cdot DRTT$$&lt;&#x2F;p&gt;
&lt;p&gt;This starts out as one second, then changes over time. Timeouts cause this value to double because a new link may be chosen that has a longer RTT than what ERTT has estimated so far.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;congestion-control&quot;&gt;Congestion Control&lt;&#x2F;h2&gt;
&lt;p&gt;A network is said to be &lt;strong&gt;congested&lt;&#x2F;strong&gt; when so much traffic is being sent through the network that many packets become lost. To combat this, TCP implements &lt;strong&gt;congestion control&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Every sender has a limited rate at which it can send traffic into its connection based on the way TCP thinks the network is congested. If it thinks it&#x27;s not very congested, then it increases the send rate, and vice versa. There are three elements to this implementation: how to limit the rate, how to perceive the congestion, and how mathematically the rate should be limited.&lt;&#x2F;p&gt;
&lt;p&gt;The mechanism at the sender keeps track of a &lt;em&gt;congestion window&lt;&#x2F;em&gt;, also known as &lt;code&gt;cwnd&lt;&#x2F;code&gt;. The amount of unacknowledged data that a sender sends must not be greater than either the congestion window or the receive window.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>UDP Explained</title>
		<published>2022-02-14T00:00:00+00:00</published>
		<updated>2022-02-14T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/udp/" type="text/html"/>
		<id>https://sharifhsn.github.io/udp/</id>
		<content type="html">&lt;p&gt;The simplest transport protocol that is used communicate between sockets is known as &lt;strong&gt;UDP&lt;&#x2F;strong&gt;, the &lt;strong&gt;User Datagram Protocol&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;udp&quot;&gt;UDP&lt;&#x2F;h2&gt;
&lt;p&gt;Let&#x27;s say we want to design the simplest transport protocol possible. All this protocol needs to do is get a message from an application at the socket and send it over the network to the other socket. However, there is one more function that it needs to perform: multiplexing&#x2F;demultiplexing.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;em&gt;segment&lt;&#x2F;em&gt; (transport layer version of a datagram) must be directed to a specific socket. There&#x27;s multiple sockets that applications communicate with and they all need to be multiplexed together to create a segment, which must then be demultiplexed for the end host to understand what socket it is sent to.&lt;&#x2F;p&gt;
&lt;p&gt;You can think of receiving multiple envelopes in your mailbox, then demultiplexing by reading who each envelope is addressed to and giving it to the member of your household to whom it is addressed. Then, when your household members want to send all of their mail out, you multiplex it into the mailbox.&lt;&#x2F;p&gt;
&lt;p&gt;UDP attaches a header with source and destination port numbers as fields for multiplexing, a length field, and a checksum to protect against packet corruption. Each of these fields is two bytes in length, resulting in a tiny 8-byte header.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>SMTP Explained</title>
		<published>2022-02-10T00:00:00+00:00</published>
		<updated>2022-02-10T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/smtp/" type="text/html"/>
		<id>https://sharifhsn.github.io/smtp/</id>
		<content type="html">&lt;p&gt;Email is the most popular way in the world to send large messages. This is a complicated process which requires its own protocol: &lt;strong&gt;SMTP&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;smtp&quot;&gt;SMTP&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;strong&gt;Simple Mail Transfer Protocol&lt;&#x2F;strong&gt; is how user agents communicate with mail servers. On a high level, email works similarly to physical mail. The mail server is like a post office with mailboxes for each user agent. When a person wants to send a message, they put the envelope in their own mailbox. The mailman user agent then takes the envelope to the post office and puts it in their server mailbox. When a person wants to retrieve a message, their mailman gets all the mail in their post office mailbox and delivers it to the person&#x27;s personal mailbox. The SMTP post office workers at the server are responsible for moving the mail between mailboxes.&lt;&#x2F;p&gt;
&lt;p&gt;To continue the post office analogy, we can imagine an email being sent between Alice and Bob. Alice lives in Hong Kong and Bob lives in San Juan, so they have different post offices. The workers at the Hong Kong post office see that there is an envelope in Alice&#x27;s message queue addressed to Hong Kong. They open a TCP connection as the client to the San Juan server and sends the envelope to the San Juan post office. The workers at San Juan now have an envelope, and they see that it is addressed to Bob. They then place the envelope in Bob&#x27;s mailbox. When Bob wants to check his email, he sends his mailman over to the post office, who returns with the email from Alice.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s examine the TCP connection a little more closely. The connection is established on port 25, which is reserved for SMTP. It does some handshaking on the application layer in order to establish the email addresses of the sender and the recipient. The simple exchange goes like this:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;server sends 220 with hostname, client responds with HELO and its own hostname&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;server confirms 250 that it&#x27;s ok&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;client tells server MAIL FROM and RCPT TO addresses and the server confirms each with 250&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;client sends &lt;code&gt;DATA&lt;&#x2F;code&gt; and server confirms with 354 that it&#x27;s ready to receive mail&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;the client sends the entirety of the message, ending with a lone period to finish the message, which the server confirms with 250&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;the client can repeat steps 3-5 for any additional messages, then sends &lt;code&gt;QUIT&lt;&#x2F;code&gt; for a server 221 response that closes the connection&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;vs-http&quot;&gt;vs. HTTP&lt;&#x2F;h2&gt;
&lt;p&gt;Both HTTP and SMTP are protocols that transfer files between clients and servers, so there are natural parallels. However, there are also significant differences.&lt;&#x2F;p&gt;
&lt;p&gt;There is a difference in who initiates the connection which defines the two. In HTTP, the &lt;em&gt;requesting&lt;&#x2F;em&gt; client initiates the connection, making it a &lt;strong&gt;pull protocol&lt;&#x2F;strong&gt;; you can think of the client &amp;quot;pulling&amp;quot; the data from the server. In SMTP, it is the &lt;em&gt;sending&lt;&#x2F;em&gt; client that initiates the connection, making it a &lt;strong&gt;push protocol&lt;&#x2F;strong&gt; where the client &amp;quot;pushes&amp;quot; the data to the other server.&lt;&#x2F;p&gt;
&lt;p&gt;SMTP also has many restrictions. The message can only be in ASCII, so any data that is sent over that is not in ASCII, like multimedia, must be encoded and decoded. HTTP allows any data to be transferred. A result of this is that HTTP data of different types like multimedia must be in its own response message, while SMTP objects are all in the same ASCII message.&lt;&#x2F;p&gt;
&lt;p&gt;There is some peripheral data that SMTP messages can include in a header, just like HTTP, such as the sender, receiver, and the subject of the email. &lt;em&gt;These are different from commands; this data is part of the actual email, not the protocol!&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mail-access&quot;&gt;Mail Access&lt;&#x2F;h2&gt;
&lt;p&gt;There&#x27;s a part of the post office analogy that has been ignored so far. How exactly does the mailman get to the post office? After all, this is another client-server connection, so there must also be a protocol that defines this interaction. We can use SMTP for the mailman delivering the envelope, as this is the same kind of &amp;quot;push&amp;quot; that the post office uses to send to the other post office. But this introduces an issue for the person on the other end; if the mailman can only push mail it already has to somewhere else, then how does Bob&#x27;s mailman get the mail on the server? There are many protocols that can define this interaction, such as &lt;strong&gt;POP3&lt;&#x2F;strong&gt;, &lt;strong&gt;IMAP&lt;&#x2F;strong&gt;, and HTTP.&lt;&#x2F;p&gt;
&lt;p&gt;In 2022, HTTP is the obvious choice for this exchange. After all, everyone accesses email through their web browser, which is making HTTP requests anyway. Why not just use an HTTP request to get the mail from the mail server? And as you might expect, almost every email provider today, from Gmail to Hotmail to Yahoo Mail uses Web-based email.&lt;&#x2F;p&gt;
&lt;p&gt;However, back when &amp;quot;user agent&amp;quot; and &amp;quot;web browser&amp;quot; weren&#x27;t synonymous, people had applications dedicated to accessing email that couldn&#x27;t access the web or use HTTP. In those times, &lt;strong&gt;Post Office Protocol—Version 3&lt;&#x2F;strong&gt; and &lt;strong&gt;Internet Mail Access Protocol&lt;&#x2F;strong&gt; were used.&lt;&#x2F;p&gt;
&lt;p&gt;POP3 is a simple and therefore limited protocol. It operates over port 110 and has three steps: authorization, transaction, and update. The post office first authenticates the mailman by asking him for a username and password before he can check your mailbox. Then, the mailman retrieves the envelope from the post office. While the mailman is at the post office, they can also do some operations like marking emails for deletion and getting statistics for your account. When the mailman leaves the post office, the workers throw away all the mail that the mailman marked for deletion.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s common for users to want to organize emails through folders like Inbox, Junk, etc. This is of course possible through user agent, but POP3 does not allow for this organization in your post office mailbox. IMAP provides this as well as many more features. It is stateful so that the user can keep the folders that it creates at the mailbox. One more important feature is its ability to lazily fetch emails from the mailbox, so the user&#x27;s entire inbox is not just sent immediately. Imagine if you had to download every email in your inbox in order to access it! I know my connection wouldn&#x27;t be able to handle my 1k+ unread emails.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>FTP Explained</title>
		<published>2022-02-07T00:00:00+00:00</published>
		<updated>2022-02-07T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/ftp/" type="text/html"/>
		<id>https://sharifhsn.github.io/ftp/</id>
		<content type="html">&lt;p&gt;Before we had Google Drive, users needed a way to access files from other people quickly and easily. The method for that was &lt;strong&gt;FTP&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;ftp&quot;&gt;FTP&lt;&#x2F;h2&gt;
&lt;p&gt;The point of the &lt;strong&gt;File Transfer Protocol&lt;&#x2F;strong&gt;, was, as is obvious, to transfer files between two hosts. Like HTTP, FTP operates between a server and client, each of which have their own filesystem that they want to access. It also creates a TCP connection which has certain verification steps to establish a connection that allows the client to copy files stored in the server or vice versa.&lt;&#x2F;p&gt;
&lt;p&gt;Unlike HTTP however, FTP operates using &lt;em&gt;two&lt;&#x2F;em&gt; parallel connections, the &lt;strong&gt;control connection&lt;&#x2F;strong&gt; and the &lt;strong&gt;data connection&lt;&#x2F;strong&gt;. As the names imply, the control connection is used for verification and command information such as which file to get in which directory, and the data connection is the connection used to send the files. This is called an &lt;em&gt;out-of-band&lt;&#x2F;em&gt; connection, unlike HTTP and SMTP, which have the request information in a header in the same connection and are therefore &lt;em&gt;in-band&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The session begins with a control connection initiated by the client to identify the user and commands. The server receives this information, and if it approves, it initiates a data connection with the client. Like HTTP 1.0, this is a non-persistent connection that is only open for the passing of a single file.&lt;&#x2F;p&gt;
&lt;p&gt;The nature of FTP authentication means that FTP must maintain state about the user account, unlike HTTP which is totally stateless by design. This introduces constraints on the number of simultaneous FTP connections.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;commands&quot;&gt;Commands&lt;&#x2F;h2&gt;
&lt;p&gt;FTP commands work like HTTP commands in request headers. They are ASCII and each lines ends with &lt;code&gt;\r\n&lt;&#x2F;code&gt;. Some example commands are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;USER username&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PASS password&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;LIST&lt;&#x2F;code&gt;: works like the &lt;code&gt;ls&lt;&#x2F;code&gt; command for the remote directory, sent over data connection&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RETR filename&lt;&#x2F;code&gt;: retrieves the file from the remote directory, over data&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;STOR filename&lt;&#x2F;code&gt;: stores the file from current directory into remote, over data&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Every command has a corresponding reply with a status code, similar to HTTP status codes.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>DNS Explained</title>
		<published>2022-01-31T00:00:00+00:00</published>
		<updated>2022-01-31T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/dns/" type="text/html"/>
		<id>https://sharifhsn.github.io/dns/</id>
		<content type="html">&lt;h2 id=&quot;protocols&quot;&gt;Protocols&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;We need protocols to define the way that messages are interpreted.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Messages are different based on what kind of information you are sending. For example, &lt;em&gt;HTTP (HyperText Transport Protocol)&lt;&#x2F;em&gt; defines the way that webpages are served. Otherwise, the bytes that are sent between a client and a server are meaningless.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;identification&quot;&gt;Identification&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;We can identify hosts using IP addresses and ports.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;With cell phones, we use telephone numbers to identify each other and call each other. Sometimes, we can store names in contacts associated with the phone numbers that are easier to remember than unique numbers.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;IP addresses&lt;&#x2F;em&gt; work the same way. Each IP address uniquely identifies a host then can send and receive information through a network. IPv4 is a 32-bit number that was traditionally used, however due to its limited scope (only $2^{32}$ ≈ 4 billion possible IP addresses). IPv6 is the new type of address that is 128-bit number with $2^{128}$ possible  addresses.&lt;&#x2F;p&gt;
&lt;p&gt;IPv4: &lt;code&gt;128.6.24.78&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;IPv6: &lt;code&gt;2001:4000:A000:C000:6000:B001:412A:8000&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;There can be more than one application running on a host, however. They can&#x27;t interfere with each other, so we need a way to distinguish them. This is done via &lt;em&gt;port numbers&lt;&#x2F;em&gt;, which are 16-bit numbers that can be bound to applications that communicate over the network. Some port numbers are reserved for special purposes, such as port 25 for email, port 80 for HTTP, port 443 for HTTPS. Port numbers are like different employees that work at a call center.&lt;&#x2F;p&gt;
&lt;p&gt;Both client and server must identify each other&#x27;s IP address and port numbers: a 4-tuple: $(S_{IP}, S_{P\#}, D_{IP}, D_{P\#})$ This tuple is a &lt;em&gt;uniquely defined bidirectional connection&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The OS manages a simple data structure of port numbers to track which are in use, no complexity involved.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;client-server-architecture&quot;&gt;Client-Server Architecture&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Many clients communicate with one always-on server.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;em&gt;server&lt;&#x2F;em&gt; is a host that is always on and has a permanent IP address that is often public. For large servers, it is often necessary to use server farms that distribute servers geographically for faster communication across the globe.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;em&gt;client&lt;&#x2F;em&gt; is one of many hosts that makes a connection with the server to access data on the server. They might connect intermittently or have dynamic IP addresses. Clients do not communicate with one another directly, instead using the server as a medium.&lt;&#x2F;p&gt;
&lt;p&gt;For example, a website server might listen on a fixed, public IP address at port 80, waiting for a HTTP request. A client might request a webpage from this server and make a connection with its own IP address and port 80. Many clients will all have different connection tuples because of their own unique IP addresses. This way, many clients can make connections without confusing the server.&lt;&#x2F;p&gt;
&lt;p&gt;One domain name can map to different IP addresses. This is how &lt;em&gt;google.com&lt;&#x2F;em&gt; can be split across thousands of servers that serve billions of requests every day to the exact same domain. The domain name can be thought of as a contact with saved name that might have many phone numbers.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dns&quot;&gt;DNS&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Domain names are converted to IP addresses through the DNS.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;DNS&lt;&#x2F;em&gt; is the &lt;em&gt;Domain Name System&lt;&#x2F;em&gt; which acts as a service to resolve IP addresses from a normal alphanumeric domain name, just like a telephone book. The DNS is itself an online service that must be accessed through a network.&lt;&#x2F;p&gt;
&lt;p&gt;The DNS listens on port 53 and the IP address is well-known. A simple DNS might be a large centralized database of names and IP addresses, around 4 billion for IPv4.&lt;&#x2F;p&gt;
&lt;p&gt;However, if this DNS crashes, that would destroy the whole Internet. Also, everybody on the Internet would be trying to access this server, which place tremendous load. It would be a big security issue and a large target for attack, both physical and virtual. Lookup in a server with billions of entries would be slow. Latency for hosts that are physically far away would be greatly increased depending on the server location. Every new host would need to be entered in the same location, which would be slow. &lt;em&gt;This does not scale!&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Real DNS is implemented as a distributed service across different countries. &lt;em&gt;Top-level domains&lt;&#x2F;em&gt; like &lt;code&gt;.com&lt;&#x2F;code&gt;, &lt;code&gt;.org&lt;&#x2F;code&gt;, &lt;code&gt;.edu&lt;&#x2F;code&gt;, are most popular and are the main domain names that people access. Each country also has it&#x27;s own top-level domain server named after it, like &lt;code&gt;.de&lt;&#x2F;code&gt;, &lt;code&gt;.uk&lt;&#x2F;code&gt;, &lt;code&gt;.be&lt;&#x2F;code&gt;. Many websites nowadays utilize country codes for special names that include the domain name e.g. &lt;code&gt;youtu.be&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Second-level servers are the most commonly accessed domain names, like &lt;code&gt;amazon.com&lt;&#x2F;code&gt;, &lt;code&gt;google.com&lt;&#x2F;code&gt;, etc. These names are separated by periods, from right to left.&lt;&#x2F;p&gt;
&lt;p&gt;Larger domain names like universities can be further namespaced, like &lt;code&gt;cs.rutgers.edu&lt;&#x2F;code&gt;. Rutgers University has its own DNS server that manages these additional domain names. The final name that contains the actual data is called the &lt;code&gt;authoritative&lt;&#x2F;code&gt; domain.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Packet Switching vs Message Switching</title>
		<published>2022-01-31T00:00:00+00:00</published>
		<updated>2022-01-31T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/packet-switching/" type="text/html"/>
		<id>https://sharifhsn.github.io/packet-switching/</id>
		<content type="html">&lt;p&gt;How do we get the best performance in sending information over the internet? What is packet switching and how can it help?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;&lt;strong&gt;Performance is bottlenecked by propagation delay and transmission time.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Propagation delay is dictated by the physical distance between the client and server. If you were to send a message to server on Mars, there would be 200 million km to travel across, aka 1000s at the speed of light! New York to Los Angeles is about 20ms at this same speed of 5μs&#x2F;km.&lt;&#x2F;p&gt;
&lt;p&gt;Transmission time is dictated by bandwidth, which tells you how many bytes per second you can send. 1MB&#x2F;s link speed will take 1ms for 1000B. The reason this happens is because as soon as the first bit is propagated, all the rest of the bits will follow which will be concentrated by bandwidth, 1μs after each other with this link speed.&lt;&#x2F;p&gt;
&lt;p&gt;For small messages in the tens or hundreds of bytes like handshake acknowledgements, propagation delay is very significant. For larger messages, propagation delay is ignored and bandwidth is considered more significant.&lt;&#x2F;p&gt;
&lt;p&gt;$RTT = 2PD$: Round-trip time is equal to twice the propagation delay.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Packet switching is faster because it is a continuous stream.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Assume 1000B&#x2F;s link speed between sender and destination. If we do message switching, it is slow. A 1000B would take 1s (duh) to go from sender to router. Similarly, it would take another second to go from router to destination, so 2 seconds in total.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s assume we split our 1000B message into 100B packets. The first packet will take 0.1s to arrive to the router and another 0.1s to arrive at the destination, so 0.2s. Each packet follows directly after the other, so the second packet takes only 0.1s total because it&#x27;s already at the router by the time the first packet is at the destination. In total, the message takes 1.1s to travel.&lt;&#x2F;p&gt;
&lt;p&gt;These benefits compound when messages are passing over multiple routers, because only the first packet has to deal with the overhead of the link speed for all the routers. All the rest of the packets will only take the time for the link speed between the last router and the destination.&lt;&#x2F;p&gt;
&lt;p&gt;However, bottlenecks can still occur when link speeds between routers are different. The weakest link will bottleneck the connection even in packet switching.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
