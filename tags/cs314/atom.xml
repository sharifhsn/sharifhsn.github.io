<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Sharif&#x27;s Page - cs314</title>
	<subtitle>Sharif Haason&#x27;s personal website for various notes and ideas</subtitle>
	<link href="https://sharifhsn.github.io/tags/cs314/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://sharifhsn.github.io/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-04-14T00:00:00+00:00</updated>
	<id>https://sharifhsn.github.io/tags/cs314/atom.xml</id>
	<entry xml:lang="en">
		<title>A Crash Course in Python</title>
		<published>2022-04-14T00:00:00+00:00</published>
		<updated>2022-04-14T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/python-crash-course/" type="text/html"/>
		<id>https://sharifhsn.github.io/python-crash-course/</id>
		<content type="html">&lt;p&gt;Python is a powerful jack-of-all-trades language that is much less limited than OCaml.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;expressions&quot;&gt;Expressions&lt;&#x2F;h2&gt;
&lt;p&gt;Arithmetic works in a very simple and clear way in Python, basically like a calculator.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 6
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;) * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# -20
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unlike in OCaml, operations can be performed between floats and integers with no issues; Python will simply change the types behind the scenes. This is called &lt;strong&gt;type coercion&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3.5 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 5.5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This causes an interesting side effect: what is the return type of this function?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;):
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;a + b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In OCaml, the equivalent function would have type &lt;code&gt;int -&amp;gt; int -&amp;gt; int&lt;&#x2F;code&gt;, since the operation &lt;code&gt;+&lt;&#x2F;code&gt; is only valid for &lt;code&gt;int&lt;&#x2F;code&gt;. However, this function is actually polymorphic in Python! In OCaml, you would call it type &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. In Python, this type is called &lt;strong&gt;Any&lt;&#x2F;strong&gt;, and operation changes based on what the types are. The reason that this is possible is because &lt;em&gt;everything&lt;&#x2F;em&gt; in Python is an object. Essentially, the variables &lt;code&gt;a&lt;&#x2F;code&gt; and &lt;code&gt;b&lt;&#x2F;code&gt; are just boxes that could contain anything, and Python only checks whether the operation &lt;code&gt;+&lt;&#x2F;code&gt; is defined for the two variables at runtime.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;strings&quot;&gt;Strings&lt;&#x2F;h2&gt;
&lt;p&gt;String manipulation is a very common operation in Python, so there are some very useful ways to handle strings built into the language.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; + &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;world&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# &amp;quot;hello world&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# &amp;quot;hellohellohello&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can also convert types to strings very easily.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# &amp;quot;5&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3.5&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# &amp;quot;3.5&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And vice versa.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 5
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;float&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;3.5&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 3.5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These are special built-in functions to make our lives earlier.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variables&quot;&gt;Variables&lt;&#x2F;h2&gt;
&lt;p&gt;Like with OCaml, there is no need to specify types as in Java. Unlike OCaml, Python does not use type inference. Instead, every variable can contain any type in a box as mentioned earlier.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;span&gt;b = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Variables in Python work differently under the hood than other languages. A variable is essentially just a name for an element.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;c = b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;c&lt;&#x2F;code&gt; here is not just equal to &lt;code&gt;b&lt;&#x2F;code&gt;... it is actually &lt;code&gt;b&lt;&#x2F;code&gt; itself! And any change you make to &lt;code&gt;b&lt;&#x2F;code&gt; will reflect in &lt;code&gt;c&lt;&#x2F;code&gt; because of that. Actual copies must be explicit.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;slices&quot;&gt;Slices&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Slices&lt;&#x2F;strong&gt; are one of the most powerful tools in Python. In fact, it might be what Python is most known for and most useful for. Slicing allows for powerful manipulation of list-like data.&lt;&#x2F;p&gt;
&lt;p&gt;Ordinary list access uses bracket notation with a single number to access a single element. Slice notation works similarly, but it allows returning multiple elements as a sub-list of the original list.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;x = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello world&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;x[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# &amp;quot;ello w&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You might notice that I just performed this operation on a string; didn&#x27;t I just say that slices work on list-like types? In Python, strings are just fancy lists of chars!.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tuples-and-lists&quot;&gt;Tuples and Lists&lt;&#x2F;h2&gt;
&lt;p&gt;A tuple is an immutable set of multiple elements, just like in OCaml. Slicing operations work the same way in that they return a subsequence tuple. There&#x27;s a weird side effect where if you slice in a way that returns a single element, you can get a single-element tuple.&lt;&#x2F;p&gt;
&lt;p&gt;Lists in Python are much more flexible in OCaml, as they can be heterogenous with any type within. They are also mutable, so elements of lists can be reassigned.&lt;&#x2F;p&gt;
&lt;p&gt;Slicing can superpower this assignment by reassigning multiple values at once&lt;&#x2F;p&gt;
&lt;h2 id=&quot;control&quot;&gt;Control&lt;&#x2F;h2&gt;
&lt;p&gt;The traditional &lt;code&gt;if&lt;&#x2F;code&gt; statements are back, but with a bit of a twist. Python has &lt;em&gt;significant whitespace&lt;&#x2F;em&gt;, which means that the amount that you indent by affects the actual execution of the code. This is quite rare.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;x == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    y = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# this tab is mandatory!
&lt;&#x2F;span&gt;&lt;span&gt;x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# this line is outside the if block
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There is a special keyword called &lt;code&gt;pass&lt;&#x2F;code&gt; which exists to allow empty blocks. Normally, this construct is forbidden:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;x == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# error!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But by using &lt;code&gt;pass&lt;&#x2F;code&gt;, this is possible:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;x == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# does nothing
&lt;&#x2F;span&gt;&lt;span&gt;x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Like in C, boolean evaluation is 0 for false, true for everything else. However, you &lt;em&gt;cannot&lt;&#x2F;em&gt; assign a variable in a conditional! So this C construct would not be allowed:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;some_func&lt;&#x2F;span&gt;&lt;span&gt;()) == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; this is allowed in C
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(x = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;some_func&lt;&#x2F;span&gt;&lt;span&gt;()) == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pass &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# this is not allowed in Python!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;functions&quot;&gt;Functions&lt;&#x2F;h2&gt;
&lt;p&gt;Functions are defined using the &lt;code&gt;def&lt;&#x2F;code&gt; keyword.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fac&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;):
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;n &amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;negative!&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;elif &lt;&#x2F;span&gt;&lt;span&gt;n == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;n * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fac&lt;&#x2F;span&gt;&lt;span&gt;(n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Functional programming can be used similarly to OCaml where everything is a function.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compose&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;g&lt;&#x2F;span&gt;&lt;span&gt;):
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;def &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;):
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;g&lt;&#x2F;span&gt;&lt;span&gt;(x))
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;foo
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compose &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f g &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;foo &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;        f g x
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; foo x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Prolog</title>
		<published>2022-03-24T00:00:00+00:00</published>
		<updated>2022-03-24T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/prolog/" type="text/html"/>
		<id>https://sharifhsn.github.io/prolog/</id>
		<content type="html">&lt;p&gt;&lt;strong&gt;Prolog&lt;&#x2F;strong&gt; is a special programming language that is not like many others. It exemplifies the paradigm of &lt;strong&gt;logic programming&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;terms&quot;&gt;Terms&lt;&#x2F;h2&gt;
&lt;p&gt;Functional programming is based on the idea that all operations exist using functions that give the same output for a given input. Imperative programming is based on the idea that we can manipulate variables and order them around like soldiers. Logic programming takes propositional logic from discrete structures and turns it into a language.&lt;&#x2F;p&gt;
&lt;p&gt;Every program is made up of &lt;strong&gt;terms&lt;&#x2F;strong&gt;, which are &lt;strong&gt;constants&lt;&#x2F;strong&gt;, &lt;strong&gt;variables&lt;&#x2F;strong&gt;, and &lt;strong&gt;compound terms&lt;&#x2F;strong&gt;. A constant is any word that is lowercase, whether it be a number, a string, or just a word. A variable is a word that begins with a capital letter.&lt;&#x2F;p&gt;
&lt;p&gt;Compound terms are relations. Relations in the logical sense are a subset of the Cartesian product of two sets, where the result set consists of elements that are contained in both. The top level name is the &lt;strong&gt;functor&lt;&#x2F;strong&gt;, and the number of arguments is the &lt;strong&gt;arity&lt;&#x2F;strong&gt;. For example, a compound term might be &lt;code&gt;male(robb)&lt;&#x2F;code&gt; where &lt;code&gt;male&lt;&#x2F;code&gt; is the functor with an arity of 1. &lt;strong&gt;The order of arguments within the compound term matters!&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Facts&lt;&#x2F;strong&gt; are a knowledge base for a particular program. Each fact is a compound term showing a relation, followed by a period. &lt;strong&gt;Rules&lt;&#x2F;strong&gt; are a generality on facts where they are facts &lt;em&gt;given&lt;&#x2F;em&gt; assumptions. A fact is just a rule that is true without assumptions. &lt;strong&gt;The order of facts&#x2F;rules is very important to the execution of code!&lt;&#x2F;strong&gt; Prolog reads from top to bottom, so the most important facts&#x2F;rules should be placed near the beginning.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(rickard, ned).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(rickard, brandon).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(rickard, lyanna).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(ned, robb).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(ned, sansa).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(ned, arya).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;queries&quot;&gt;Queries&lt;&#x2F;h2&gt;
&lt;p&gt;Once we have our knowledge base, we can &lt;strong&gt;query&lt;&#x2F;strong&gt; for information.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;?- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(ned, sansa).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This query will return true because it is in our list of facts. However, what happens if we query something it doesn&#x27;t know?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;?- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(ned, bran).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Prolog operates on the &lt;strong&gt;closed world assumption&lt;&#x2F;strong&gt;, which means that it only knows what it&#x27;s been told. If it doesn&#x27;t know something, it will assume falsity. So Prolog will say the Ned is &lt;em&gt;not&lt;&#x2F;em&gt; Bran&#x27;s father, despite it having no idea whether that is the case.&lt;&#x2F;p&gt;
&lt;p&gt;There are also &lt;strong&gt;existential queries&lt;&#x2F;strong&gt;. Instead of asking a boolean question, it asks if a fact exists.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;?- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(ned, X).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This query asks for all the relations &lt;code&gt;father&lt;&#x2F;code&gt; where &lt;code&gt;ned&lt;&#x2F;code&gt; is the first argument. It will return&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;X = robb &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;X = sansa &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;X = arya .
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;in the order that the facts are laid out. The semicolon is the logical OR in Prolog, so it&#x27;s saying that either one of the results is true. It would return false if there are no facts that satisfies the query.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rules&quot;&gt;Rules&lt;&#x2F;h2&gt;
&lt;p&gt;Rules in general can be any logical statements from facts that are inferred inductively. The general form is&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;H :- B1, B2, B3, ..., BN
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;means that the head &lt;code&gt;H&lt;&#x2F;code&gt; is true if &lt;code&gt;B1&lt;&#x2F;code&gt; ∧ &lt;code&gt;B2&lt;&#x2F;code&gt; ∧ &lt;code&gt;B3&lt;&#x2F;code&gt; ... etc.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parent&lt;&#x2F;span&gt;&lt;span&gt;(X, Y) :- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;father&lt;&#x2F;span&gt;&lt;span&gt;(X, Y).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;means that the relation &lt;code&gt;parent&lt;&#x2F;code&gt; exists between &lt;code&gt;X&lt;&#x2F;code&gt; and &lt;code&gt;Y&lt;&#x2F;code&gt; as long as the relation &lt;code&gt;father&lt;&#x2F;code&gt; exists between &lt;code&gt;X&lt;&#x2F;code&gt; and &lt;code&gt;Y&lt;&#x2F;code&gt;. We can construct rules recursively as well:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ancestor&lt;&#x2F;span&gt;&lt;span&gt;(X, Y) :- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parent&lt;&#x2F;span&gt;&lt;span&gt;(X, Y)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ancestor&lt;&#x2F;span&gt;&lt;span&gt;(X, Y) :- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parent&lt;&#x2F;span&gt;&lt;span&gt;(X, Z), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ancestor&lt;&#x2F;span&gt;&lt;span&gt;(Z, Y)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This defines ancestor in two ways. The first rule says that &lt;code&gt;X&lt;&#x2F;code&gt; is an ancestor of &lt;code&gt;Y&lt;&#x2F;code&gt; as long as &lt;code&gt;X&lt;&#x2F;code&gt; is a parent of &lt;code&gt;Y&lt;&#x2F;code&gt;. The second rule introduces an additional definition where &lt;code&gt;X&lt;&#x2F;code&gt; is an ancestor of &lt;code&gt;Y&lt;&#x2F;code&gt; as long as &lt;code&gt;X&lt;&#x2F;code&gt; is a parent of some &lt;code&gt;Z&lt;&#x2F;code&gt; which is an ancestor of &lt;code&gt;Y&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can almost think of this like a list, where parent means adjacent and ancestor means inorder. Of course two elements are inorder if they are adjacent, that&#x27;s the first rule. However, if we can imagine a long list, two elements are inorder if the adjacent element to &lt;code&gt;X&lt;&#x2F;code&gt; is inorder previous to &lt;code&gt;Y&lt;&#x2F;code&gt;! The logic applies in any general situation; this is the advantage of the logical paradigm.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;unification&quot;&gt;Unification&lt;&#x2F;h2&gt;
&lt;p&gt;The core of how Prolog will compute answers is through &lt;strong&gt;unification&lt;&#x2F;strong&gt;, which is similar to pattern matching. It has three unification conditions:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;identical constants will be unified&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;variables will always unify&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;compound terms will unify if functor and arity match as well as their arguments, recursively (using the top two rules)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;lists&quot;&gt;Lists&lt;&#x2F;h2&gt;
&lt;p&gt;Data structures seem pretty incongruent with our idea of logical programming so far. Lists are defined similarly to OCaml as recursive data structures.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;] % list
&lt;&#x2F;span&gt;&lt;span&gt;[] % nil
&lt;&#x2F;span&gt;&lt;span&gt;[H | T] % head cons tail
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To find the last element of a list, we can use this rule&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;last&lt;&#x2F;span&gt;&lt;span&gt;([H], H).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;last&lt;&#x2F;span&gt;&lt;span&gt;([_ | T], V) :- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;last&lt;&#x2F;span&gt;&lt;span&gt;(T, V).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first rule is the base case, where if there is only one element in a list, that element is the &amp;quot;last element&amp;quot;. Then, the second rule is recursively defined. If the first argument &lt;&#x2F;p&gt;
&lt;h2 id=&quot;arithmetic&quot;&gt;Arithmetic&lt;&#x2F;h2&gt;
&lt;p&gt;The arithmetic operators are built into Prolog, and are built as relations between terms. Arithmetic equality is &lt;em&gt;not&lt;&#x2F;em&gt; the same thing as unification. If you want to check for arithmetic equality, you must use &lt;code&gt;is&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;is&lt;&#x2F;code&gt; operator evaluates the right hand expression and unifies the expression with the left. There can be variables present, but the variables need to be defined as some ground value. You can&#x27;t create an algebraic equation using &lt;code&gt;is&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Basic arithmetic operators are also built in, but only operate on numerals. If you try to apply, for instance, &lt;code&gt;+&lt;&#x2F;code&gt;, to lowercase word constants, there will be an error.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;backtracking&quot;&gt;Backtracking&lt;&#x2F;h2&gt;
&lt;p&gt;Prolog computes the length of a list very similar to OCaml. An example OCaml length function might be:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; len t + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The Prolog rules are similar:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;([], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;([H | T], N) :- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(T, M), N is M + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The relation &lt;code&gt;len&lt;&#x2F;code&gt; with arity 2 defined on the empty list maps to 0, obviously. The relation &lt;code&gt;len&lt;&#x2F;code&gt; with arity 2 and the first argument being a list with head and tail is the actual recursive part we are interested in.&lt;&#x2F;p&gt;
&lt;p&gt;You might raise an eyebrow at the use of &lt;code&gt;is&lt;&#x2F;code&gt; in the second rule; after all, didn&#x27;t I just say that the right hand side must have ground terms? We don&#x27;t know what &lt;code&gt;M&lt;&#x2F;code&gt; is!&lt;&#x2F;p&gt;
&lt;p&gt;Actually, we do know. You can think of the order of clauses as the imperative definition of variables. The variable &lt;code&gt;M&lt;&#x2F;code&gt; is declared and initialized with the first &lt;code&gt;len&lt;&#x2F;code&gt; clause, and it can then be used in the second clause. If we put the second clause first, Prolog would raise an error.&lt;&#x2F;p&gt;
&lt;p&gt;You might notice a pattern here. The function is almost identical to the OCaml function, except for one difference. In the functional paradigm, every function evaluates to an expression which is returned within the function, and those are the values that are used for every operation. In the logical paradigm, there is no implicit return. &lt;code&gt;len(T, M)&lt;&#x2F;code&gt; is the same thing as &lt;code&gt;M = len(T)&lt;&#x2F;code&gt;!&lt;&#x2F;p&gt;
&lt;p&gt;The length is computed using &lt;strong&gt;backtracking&lt;&#x2F;strong&gt;. It will try every possible rule for &lt;code&gt;len&lt;&#x2F;code&gt; and then evaluate every single one. You can think of a depth first search of the tree of rules.&lt;&#x2F;p&gt;
&lt;p&gt;Every point at which there are multiple branches is called a &lt;strong&gt;choice point&lt;&#x2F;strong&gt;. In the &lt;code&gt;len&lt;&#x2F;code&gt; example, it can choose to either check the fact for &lt;code&gt;[]&lt;&#x2F;code&gt; or the recursive rule.&lt;&#x2F;p&gt;
&lt;p&gt;Backtracking can cause unexpected results. Say we try to query&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;?- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(A, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re querying for a list of size 2 which &lt;em&gt;doesn&#x27;t exist&lt;&#x2F;em&gt;. What would happen?&lt;&#x2F;p&gt;
&lt;p&gt;Well, Prolog will try to find a matching branch to an existing rule. It will fail the first rule most of the time, so it will match the second rule. Because &lt;code&gt;M = N - 1&lt;&#x2F;code&gt;, when trying to find &lt;code&gt;M&lt;&#x2F;code&gt; it will subtract from the second argument and backtrack. It will eventually match to return the result &lt;code&gt;A = [h1, h2];&lt;&#x2F;code&gt; when it matches 0 as the length and backtracks to adding arbitrary variables to the list of T.&lt;&#x2F;p&gt;
&lt;p&gt;But then something unexpected happens. After printing that last result, Prolog would spin on and on, never returning again. That&#x27;s because although we have matched the first rule and returned a list, Prolog will try every rule to see if it matches. And in fact, the second rule does match &lt;code&gt;[T2, 0]&lt;&#x2F;code&gt; because a variable will match any value. Prolog will endlessly backtrack because a choice will always be available that can match the new recursion. This is much different from OCaml which will only execute the first match arm that matches. You need to be careful in Prolog in order to prevent this kind of result.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tail-recursion&quot;&gt;Tail Recursion&lt;&#x2F;h2&gt;
&lt;p&gt;Our &lt;code&gt;len&lt;&#x2F;code&gt; function is not tail recursive, since it adds on to the recursive call. In order to optimize our code, including an accumulator will aid because of tail recursion which we have discussed before.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len2&lt;&#x2F;span&gt;&lt;span&gt;([], Acc, Acc).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len2&lt;&#x2F;span&gt;&lt;span&gt;([H | T], Acc, N) :- M is Acc + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len2&lt;&#x2F;span&gt;&lt;span&gt;(T, M, N).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;What we&#x27;ve done here is shift the &lt;code&gt;is&lt;&#x2F;code&gt; clause before the recursive call, which means we don&#x27;t need to hold on to that choice when recursively calling &lt;code&gt;len2&lt;&#x2F;code&gt;, since it&#x27;s guaranteed to already be checked.&lt;&#x2F;p&gt;
&lt;p&gt;You might ask, why do we even need to have that &lt;code&gt;is&lt;&#x2F;code&gt; clause? We might as well directly call &lt;code&gt;len2(T, Acc + 1, N)&lt;&#x2F;code&gt;. However, there&#x27;s an issue here. The &lt;code&gt;len2&lt;&#x2F;code&gt; relation only &lt;em&gt;unifies&lt;&#x2F;em&gt; terms, which is a powerful operation, but it &lt;em&gt;does not evaluate them&lt;&#x2F;em&gt;. For a list &lt;code&gt;[1, 5, 7, 3]&lt;&#x2F;code&gt; it would show &lt;code&gt;N = 0 + 1 + 1 + 1 + 1&lt;&#x2F;code&gt;, not &lt;code&gt;N = 4&lt;&#x2F;code&gt; which would be correct. In order to make this correct, we need to evaluate the addition before making the recursive call into the second clause because that clause does not perform any evaluation.&lt;&#x2F;p&gt;
&lt;p&gt;This means that when we call &lt;code&gt;len2&lt;&#x2F;code&gt; we need to do &lt;code&gt;len2([], 0, X)&lt;&#x2F;code&gt;. This is a little annoying; we always know that our accumulator will begin at 0, why do we need to include it? There is a way to elide this definition:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len2&lt;&#x2F;span&gt;&lt;span&gt;([)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;append&quot;&gt;Append&lt;&#x2F;h2&gt;
&lt;p&gt;Another instructive example is the simple list append.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;append &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p q&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;match p with
&lt;&#x2F;span&gt;&lt;span&gt;    | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]&lt;&#x2F;span&gt;&lt;span&gt; -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;q
&lt;&#x2F;span&gt;&lt;span&gt;    | [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h&lt;&#x2F;span&gt;&lt;span&gt; :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;] -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h&lt;&#x2F;span&gt;&lt;span&gt; :: (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;append t q&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;append&lt;&#x2F;span&gt;&lt;span&gt;([], Q, Q).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;append&lt;&#x2F;span&gt;&lt;span&gt;([H | P], Q, [H | R]) :- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;append&lt;&#x2F;span&gt;&lt;span&gt;(P, Q, R).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;prefix-suffix&quot;&gt;Prefix&#x2F;Suffix&lt;&#x2F;h2&gt;
&lt;p&gt;For a given list, we can place a separator in the list. Every element prior to the separator is the &lt;strong&gt;prefix&lt;&#x2F;strong&gt; and every element after is the &lt;strong&gt;suffix&lt;&#x2F;strong&gt;. The separator can be anywhere, including before or after every element.&lt;&#x2F;p&gt;
&lt;p&gt;We can get all possible prefixes&#x2F;suffixes for a list for all separators:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;?- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span&gt;(X, [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;X&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[]&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;X&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;X&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;1, 2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;X&lt;&#x2F;span&gt;&lt;span&gt; = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;[&lt;&#x2F;span&gt;&lt;span&gt;1, 2, 3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;]&lt;&#x2F;span&gt;&lt;span&gt;.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s think about how to build this out logically. We need to find all lists which are possible prefixes of this list. That means we don&#x27;t want to capture, for example, &lt;code&gt;[2, 3]&lt;&#x2F;code&gt;, because that is not a possible prefix. We have to start from the left and include from there.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;prefix&lt;&#x2F;span&gt;&lt;span&gt;([], []).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The empty list should map onto the empty list, naturally&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generate-and-test&quot;&gt;Generate and Test&lt;&#x2F;h2&gt;
&lt;p&gt;We need a general approach to solve problems from a Prolog standpoint. The paradigm is very different from imperative or functional, so we can&#x27;t just look at it the way that that OCaml or Java does.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s make &lt;code&gt;take&lt;&#x2F;code&gt;, which will remove exactly one element &lt;code&gt;x&lt;&#x2F;code&gt; from a list.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;([H | T], H, T).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;([H | T], R, [H | S]) :- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;(T, R, S).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The first rule is the most obvious. If the element is at the head of the list, we can just return the tail of the list. This is our base case.&lt;&#x2F;p&gt;
&lt;p&gt;The second rule maps onto the case in the middle of the list. To imagine this, let&#x27;s use an example&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span&gt;?- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;([&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, T).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We try to unify this to the first rule, but it fails because 2 is not at the head of the first list. The second rule will unify because the first element is a list with multiple values, the second is a variable that will unify anything, and the third element is a variable that will unify anything. Upon match, it will query &lt;code&gt;take([2, 3], 2, S)&lt;&#x2F;code&gt;. This query will unify with the first rule, which will replace &lt;code&gt;S&lt;&#x2F;code&gt; with the value &lt;code&gt;[ 3 ]&lt;&#x2F;code&gt;. Once that &lt;code&gt;S&lt;&#x2F;code&gt; is unified, the rule will backtrack to the initial query which asked for &lt;code&gt;[H | S]&lt;&#x2F;code&gt;. Well, &lt;code&gt;H&lt;&#x2F;code&gt; in that initial case was &lt;code&gt;1&lt;&#x2F;code&gt; so our final return &lt;code&gt;T&lt;&#x2F;code&gt; will be &lt;code&gt;[1, 3]&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;By extending &lt;code&gt;take&lt;&#x2F;code&gt;, we can implement other functions like permutations.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;perm&lt;&#x2F;span&gt;&lt;span&gt;([], []).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;perm&lt;&#x2F;span&gt;&lt;span&gt;(L, [H | T]) :- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;take&lt;&#x2F;span&gt;&lt;span&gt;(L, H, R), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;perm&lt;&#x2F;span&gt;&lt;span&gt;(R, T).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s permute &lt;code&gt;[1, 2, 3]&lt;&#x2F;code&gt; once again.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span&gt;?- perm([&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;], X).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It will not unify with the first rule, but it will with the second, obviously. The second clause will permute the list with the head taken away. Now, you might notice that &lt;code&gt;H&lt;&#x2F;code&gt; is not an explicit value here as when we used it earlier. Prolog seeing this will try to unify it with &lt;em&gt;every&lt;&#x2F;em&gt; value in the list, so &lt;code&gt;take&lt;&#x2F;code&gt; will be queried three times, with each value in the list being used in &lt;code&gt;H&lt;&#x2F;code&gt;. The resulting &lt;code&gt;R&lt;&#x2F;code&gt; from each of those queries is permuted again. The &lt;code&gt;H&lt;&#x2F;code&gt; used in &lt;code&gt;take&lt;&#x2F;code&gt; will be the head that is cons the backtracked form.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;[1, 2, 3]&lt;&#x2F;code&gt; will become &lt;code&gt;take([1, 2, 3], H, R)&lt;&#x2F;code&gt;. Prolog will run through every choice, starting with &lt;code&gt;take([ 1,[1, 2, 3] R)&lt;&#x2F;code&gt; which will unify &lt;code&gt;R&lt;&#x2F;code&gt; with &lt;code&gt;[2, 3]&lt;&#x2F;code&gt;. Now, the &lt;code&gt;perm&lt;&#x2F;code&gt; clause will be &lt;code&gt;perm([2, 3], T)&lt;&#x2F;code&gt;. Let&#x27;s assume that this gives all valid permutations of &lt;code&gt;[2, 3]&lt;&#x2F;code&gt; i.e. &lt;code&gt;[2, 3]&lt;&#x2F;code&gt; and &lt;code&gt;[3, 2]&lt;&#x2F;code&gt;. Well, the resulting match on the original &lt;code&gt;X&lt;&#x2F;code&gt; would be &lt;code&gt;H | [2, 3]&lt;&#x2F;code&gt; and &lt;code&gt;H | [3, 2]&lt;&#x2F;code&gt; or for this particular unification, &lt;code&gt;[1, 2, 3]&lt;&#x2F;code&gt; and &lt;code&gt;[1, 3, 2]&lt;&#x2F;code&gt;. This conclusively shows the inductive step, and the base case is trivially the empty list.&lt;&#x2F;p&gt;
&lt;p&gt;As you might be able to tell from these examples, there is a general strategy to solving problems in Prolog.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Generate a solution.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Test if it is valid.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;If not valid, backtrack and try another solution.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;quicksort&quot;&gt;Quicksort&lt;&#x2F;h2&gt;
&lt;p&gt;One way to sort a list in Prolog is to use the generate and test method. You can generate all permutations of a list, and test whether each list is sorted. This is obviously incredibly inefficient with a Big O of \(O(n!)\).&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;partition&lt;&#x2F;span&gt;&lt;span&gt;([], Y, [], []).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;partition&lt;&#x2F;span&gt;&lt;span&gt;([X|Xs], Y, {X|Ls], Rs) :- X =&amp;lt; Y, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;partition&lt;&#x2F;span&gt;&lt;span&gt;(Xs, Y, Ls, Rs).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;partition&lt;&#x2F;span&gt;&lt;span&gt;([X|Xs], Y, Ls, [X|Rs]) :- X &amp;gt; Y, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;partition&lt;&#x2F;span&gt;&lt;span&gt;(Xs, Y, Ls, Rs).
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;quicksort&lt;&#x2F;span&gt;&lt;span&gt;([H | T], SL) :-
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;partition&lt;&#x2F;span&gt;&lt;span&gt;(T, H, Ls, Rs), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;quicksort&lt;&#x2F;span&gt;&lt;span&gt;(Ls, SLs), quicksort (Rs, SRs), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;append&lt;&#x2F;span&gt;&lt;span&gt;(SLs, [H|SRs], SL).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;quicksort&lt;&#x2F;span&gt;&lt;span&gt;([], []).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This quicksort method is a very declarative manifestation of how to do quicksort in plain English. Partition the list along the pivot, quicksort the left and right, then combine them.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;8-queens&quot;&gt;8-Queens&lt;&#x2F;h2&gt;
&lt;p&gt;One classic problem in math is to find all of the arrangements of queens on a chessboard where none of the queens threaten each other. We will find it for 8 queens on an 8×8 chessboard.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s cut down on our sample space, because there are &lt;em&gt;a lot&lt;&#x2F;em&gt; of permutations. If a queen is next to another, it obviously threatens it. In fact, because queens can never share the same row or column, that massively cuts our sample space. We can describe our solution as an array of eight values from one through eight, where the index of the value is the row of the queen and the value itself being its column. This way of describing the sample space not only cuts our sample space but makes our computation simpler. However, we have not checked the diagonals. That is what we need Prolog for.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;pro&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-pro &quot;&gt;&lt;code class=&quot;language-pro&quot; data-lang=&quot;pro&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;checkBoard&lt;&#x2F;span&gt;&lt;span&gt;([H | T]) :- L is H - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, R is H + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;checkRow&lt;&#x2F;span&gt;&lt;span&gt;(T, L, R), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;checkBoard&lt;&#x2F;span&gt;&lt;span&gt;(T).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;checkRow&lt;&#x2F;span&gt;&lt;span&gt;([H | T], L, R) :- H =\= L, H =\= R, LN is L - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, RN is R + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;checkRow&lt;&#x2F;span&gt;&lt;span&gt;(T, LN, RN)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;checkBoard&lt;&#x2F;span&gt;&lt;span&gt;([]).
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;checkRow&lt;&#x2F;span&gt;&lt;span&gt;([], _, _).
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Lambda Calculus</title>
		<published>2022-03-03T00:00:00+00:00</published>
		<updated>2022-03-03T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/lambda-calculus/" type="text/html"/>
		<id>https://sharifhsn.github.io/lambda-calculus/</id>
		<content type="html">&lt;p&gt;When we discuss the principles of programming languages, &lt;strong&gt;lambda calculus&lt;&#x2F;strong&gt; is the bedrock of our discussion. It is the most abstract, formal way to describe functions and application.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;turing-completeness&quot;&gt;Turing Completeness&lt;&#x2F;h2&gt;
&lt;p&gt;A programming language is said to be &lt;strong&gt;Turing complete&lt;&#x2F;strong&gt; if it can compute any function also computable on a Turing machine. It must either be able to emulate a Turing machine, or it must be able to emulate a Turing complete language.&lt;&#x2F;p&gt;
&lt;p&gt;Although this is a powerful definition, in truth it is a simple one to satisfy. Features like loops and currying are not related to Turing completeness.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;syntax&quot;&gt;Syntax&lt;&#x2F;h2&gt;
&lt;p&gt;Lambda calculus is a very simple language which only uses functions and applications, but is still Turing complete.&lt;&#x2F;p&gt;
&lt;p&gt;An expression in lambda calculus is defined as&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bnf&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bnf &quot;&gt;&lt;code class=&quot;language-bnf&quot; data-lang=&quot;bnf&quot;&gt;&lt;span&gt;e ::= x    # variable
&lt;&#x2F;span&gt;&lt;span&gt;    | λx.e # abstraction (function definition)
&lt;&#x2F;span&gt;&lt;span&gt;    | e e  # application (function call)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Everything is a function in lambda calculus. We can make a simple interpreter in OCaml as with Imp:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type exp &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    | Var &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;of string
&lt;&#x2F;span&gt;&lt;span&gt;    | Lam &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;of string &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;exp
&lt;&#x2F;span&gt;&lt;span&gt;    | App &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;of exp &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;exp
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;in the same order that was defined earlier. &lt;code&gt;Lam&lt;&#x2F;code&gt; here is similar to &lt;code&gt;Fun&lt;&#x2F;code&gt; for Imp. The lambda calculus expression&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bnf&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bnf &quot;&gt;&lt;code class=&quot;language-bnf&quot; data-lang=&quot;bnf&quot;&gt;&lt;span&gt;(λx.λy.x y) λx.x x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;can be deconstructed to its AST as&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span&gt;App(
&lt;&#x2F;span&gt;&lt;span&gt;    Lam(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        Lam(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;y&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            App(Var &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, Var &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;y&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;        )
&lt;&#x2F;span&gt;&lt;span&gt;    ),
&lt;&#x2F;span&gt;&lt;span&gt;    Lam(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        App(Var &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;x&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, Var &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;y&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s parse this out forwards. First we read that there is a parenthesis, which means that there is an expression enclosed within. There is a \(λ\), which means that the expression is a lambda. The next letter is &lt;code&gt;x&lt;&#x2F;code&gt;, which is the name of the &lt;code&gt;Lam&lt;&#x2F;code&gt;. The period following separates the function definition to the containing expression, which continues to another \(λ\). That means that the containing expression is also a &lt;code&gt;Lam&lt;&#x2F;code&gt;, which is called &amp;quot;y&amp;quot;. The containing expression is now an &lt;code&gt;App&lt;&#x2F;code&gt; which is composed of two &lt;code&gt;Var&lt;&#x2F;code&gt;s. This is the end of the nesting because we hit the end parenthesis. The same logic applies for the second expression but with less nesting. Since we have two expressions at the top-level, the full expression is an &lt;code&gt;App&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The scope of \(λ\) extends as far to the right as possible, excepting parentheses. This is why we needed the parentheses for the first term in the above statement, otherwise the first \(λ\) would extend throughout the entire statement. The application, however, is left-associative, like OCaml. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;beta-reduction&quot;&gt;Beta Reduction&lt;&#x2F;h2&gt;
&lt;p&gt;A function call of type &lt;code&gt;(λx.e1) e2&lt;&#x2F;code&gt; replaces all instances of &lt;code&gt;x&lt;&#x2F;code&gt; in &lt;code&gt;e1&lt;&#x2F;code&gt; with &lt;code&gt;e2&lt;&#x2F;code&gt;. That means that we can substitute this statement with &lt;code&gt;e1{e2&#x2F;x}&lt;&#x2F;code&gt;. This is called &lt;strong&gt;beta reduction&lt;&#x2F;strong&gt;. All we have done is apply the function and replace the formal parameters through substitutions. Beta reductions should always be idempotent for the statement. When no more beta reductions can be performed on a term, then it is said to be in &lt;em&gt;beta normal form&lt;&#x2F;em&gt;, for example &lt;code&gt;λx.e&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Another example will be instructive here. Take the term &lt;code&gt;(λx.λz.x z) y&lt;&#x2F;code&gt;. This is a function application, since it has two terms. It follows the form that we stated earlier, so we can substitute all instances of &lt;code&gt;y&lt;&#x2F;code&gt; on the outside \(λ\). This would give us the final term &lt;code&gt;λz.(y z)&lt;&#x2F;code&gt; eliminating the outside &lt;code&gt;λx&lt;&#x2F;code&gt; and replacing the &lt;code&gt;x&lt;&#x2F;code&gt; in the inner term with &lt;code&gt;y&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;alpha-conversion&quot;&gt;Alpha Conversion&lt;&#x2F;h2&gt;
&lt;p&gt;Lambda calculus is &lt;strong&gt;statically scoped&lt;&#x2F;strong&gt; which means that variable definitions are only scoped locally. That means that within a function, you can rename &lt;em&gt;bound&lt;&#x2F;em&gt; variables with the same meaning. This is called &lt;strong&gt;alpha conversion&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;An important distinction here is between a free and bound variable. Free variables are not contained within a lambda, while bound variables are. For example, in &lt;code&gt;(λy.λz.y z x)&lt;&#x2F;code&gt;, &lt;code&gt;y&lt;&#x2F;code&gt; and &lt;code&gt;z&lt;&#x2F;code&gt; are bound to &lt;code&gt;λz&lt;&#x2F;code&gt; and &lt;code&gt;λy&lt;&#x2F;code&gt;, respectively, while &lt;code&gt;x&lt;&#x2F;code&gt; is free. &lt;code&gt;λy&lt;&#x2F;code&gt; contains the &lt;code&gt;App&lt;&#x2F;code&gt; of &lt;code&gt;λz&lt;&#x2F;code&gt; and &lt;code&gt;z&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Currying Arguments in a Function</title>
		<published>2022-02-21T00:00:00+00:00</published>
		<updated>2022-02-21T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/curry/" type="text/html"/>
		<id>https://sharifhsn.github.io/curry/</id>
		<content type="html">&lt;p&gt;&lt;strong&gt;Currying&lt;&#x2F;strong&gt; is the concept of having multiple arguments in a function. OCaml defaults to currying its functions. &lt;code&gt;int -&amp;gt; int -&amp;gt; int&lt;&#x2F;code&gt; is a function that takes two &lt;code&gt;int&lt;&#x2F;code&gt;s and returns an &lt;code&gt;int&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;The &lt;code&gt;-&amp;gt;&lt;&#x2F;code&gt; is &lt;em&gt;right-associated&lt;&#x2F;em&gt; and the function application is &lt;em&gt;left-associated&lt;&#x2F;em&gt;. The last element of the function definition is always the return type, but calling a function always counts arguments from the left.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a b &lt;&#x2F;span&gt;&lt;span&gt;= a &#x2F; b;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span&gt;= fun a -&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;b &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; a &#x2F; b);;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These two lines are equivalent because the second line is just the uncurried function separated into two parts. The &lt;code&gt;fun&lt;&#x2F;code&gt; lambda only has one argument, and the &lt;code&gt;-&amp;gt;&lt;&#x2F;code&gt; keyword is right-associated so &lt;code&gt;b&lt;&#x2F;code&gt; is considered part of the arguments.&lt;&#x2F;p&gt;
&lt;p&gt;Currying allows you to pass only a portion of the expected arguments to the function, the same way that Python uses keyword arguments.&lt;&#x2F;p&gt;
&lt;p&gt;Another way to enable multiple arguments is by using a tuple that contains both arguments, which are destructured in the function definition. However, the advantage of currying is that you can separate the call of the function from the arguments.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;a b &lt;&#x2F;span&gt;&lt;span&gt;= a + b;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;addthree &lt;&#x2F;span&gt;&lt;span&gt;= add &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;;;
&lt;&#x2F;span&gt;&lt;span&gt;addthree &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* evaluates to 7 *)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code allows &lt;code&gt;addthree&lt;&#x2F;code&gt; to exist as an implementation of &lt;code&gt;add&lt;&#x2F;code&gt; with a specific argument already given.&lt;&#x2F;p&gt;
&lt;p&gt;However, it&#x27;s not all roses with currying. Function need to retain state regardless of stack state, so the local variable &lt;code&gt;3&lt;&#x2F;code&gt; that is temporarily in the function &lt;code&gt;addthree&lt;&#x2F;code&gt; may not always be there. Anonymous functions may not have the same call stack.&lt;&#x2F;p&gt;
&lt;p&gt;In C-like languages, local variables are contained within their own stack frames. When a function calls another function, the new stack frame that is created contains its own local variables. If a variable is declared, then initialized through a function call, that variable contains junk until the function returns.&lt;&#x2F;p&gt;
&lt;p&gt;If we return a function that references a local variable in another function, reading it off the stack can get confusing. The first variable you look for is still uninitialized, so you need to evaluate where that variable is coming from to understand.&lt;&#x2F;p&gt;
&lt;p&gt;We solve this problem using &lt;strong&gt;static scoping&lt;&#x2F;strong&gt;. Nonlocal names refer to their nearest binding in the program text. This is also known as lexical scoping. If two variables have the same name in an inner scope and an outer scope, then we read the one in the inner scope first.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Data Types in OCaml</title>
		<published>2022-02-17T00:00:00+00:00</published>
		<updated>2022-02-17T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/data-types/" type="text/html"/>
		<id>https://sharifhsn.github.io/data-types/</id>
		<content type="html">&lt;p&gt;When we make our programs more and more complex, we need more complex data types as well. We have only used OCaml&#x27;s built-in data types, how can we construct our own data types?&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;type&quot;&gt;&lt;code&gt;type&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;code&gt;type&lt;&#x2F;code&gt; keyword is similar to the &lt;code&gt;typedef&lt;&#x2F;code&gt; keyword in C, except more limited in scope. A &lt;code&gt;type&lt;&#x2F;code&gt; can only be multiple variants of arbitrary values.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* coin is enum with variants Heads and Tails*)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type coin &lt;&#x2F;span&gt;&lt;span&gt;= Heads | Tails
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each variant can also contain data of other data types.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type shape &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt; | Rect &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;of float &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;float
&lt;&#x2F;span&gt;&lt;span&gt; | Circle &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;of float
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;r &lt;&#x2F;span&gt;&lt;span&gt;= Rect (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4.0&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* r has type shape *)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;shape&lt;&#x2F;code&gt; here has two variants. It can either be a tuple of two &lt;code&gt;float&lt;&#x2F;code&gt;s when it is a &lt;code&gt;Rect&lt;&#x2F;code&gt;, or it can be a single &lt;code&gt;float&lt;&#x2F;code&gt; when it is a &lt;code&gt;Circle&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These data types are also known as &lt;em&gt;algebraic data types&lt;&#x2F;em&gt; or &lt;em&gt;tagged unions&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;option&quot;&gt;Option&lt;&#x2F;h2&gt;
&lt;p&gt;ADTs can be useful when we want to ensure the complete handling of all cases. For example, if an object is nullable, it is useful to make sure that we must handle the null case instead of passing that off to the developer who might carelessly not handle it. This is where the &lt;strong&gt;option&lt;&#x2F;strong&gt; type comes from.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &amp;#39;a option &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt; | Some &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;of &amp;#39;a
&lt;&#x2F;span&gt;&lt;span&gt; | None
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; keyword means that that the type &lt;code&gt;option&lt;&#x2F;code&gt; is polymorphic, and the variant &lt;code&gt;Some&lt;&#x2F;code&gt; will contain whatever type that &lt;code&gt;option&lt;&#x2F;code&gt; is defined for. When handling an &lt;code&gt;option&lt;&#x2F;code&gt;, you &lt;em&gt;must&lt;&#x2F;em&gt; destructure it into its &lt;code&gt;Some&lt;&#x2F;code&gt; and &lt;code&gt;None&lt;&#x2F;code&gt; variants and handle both cases, otherwise OCaml will warn you for a non-exhaustive pattern match.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;list&quot;&gt;List&lt;&#x2F;h2&gt;
&lt;p&gt;We can actually define our own list data type as a &lt;strong&gt;recursive data type&lt;&#x2F;strong&gt;, which is a data type which contains itself.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &amp;#39;a list &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt; | Nil
&lt;&#x2F;span&gt;&lt;span&gt; | Cons &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;of &amp;#39;a &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a list
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here, &lt;code&gt;list&lt;&#x2F;code&gt; has two variants, &lt;code&gt;Nil&lt;&#x2F;code&gt; and a &lt;code&gt;Cons&lt;&#x2F;code&gt; tuple of an element and a &lt;code&gt;list&lt;&#x2F;code&gt;. If we think of the traditional list data type, this is actually just a more verbose version. &lt;code&gt;[]&lt;&#x2F;code&gt; is sugar for &lt;code&gt;Nil&lt;&#x2F;code&gt; and &lt;code&gt;::&lt;&#x2F;code&gt; is sugar for &lt;code&gt;Cons&lt;&#x2F;code&gt; tuple. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;Nil -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;Cons (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ (len t)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* same as *)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;len &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;_ &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ (len t)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;exceptions&quot;&gt;Exceptions&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Exceptions&lt;&#x2F;strong&gt; are a special data type used for errors in OCaml. Exceptions are similar to type constructors in that they can take arguments or have none.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;exception &lt;&#x2F;span&gt;&lt;span&gt;Sign of &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; n &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;then
&lt;&#x2F;span&gt;&lt;span&gt;        raise (Sign n)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span&gt;        raise (Failure &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can &lt;code&gt;raise&lt;&#x2F;code&gt; an exception with arguments whenever we want, which will exit the function with the exception name and its arguments. &lt;code&gt;Failure&lt;&#x2F;code&gt; is a generic exception type that is used with strings.&lt;&#x2F;p&gt;
&lt;p&gt;There is also special &lt;code&gt;try&lt;&#x2F;code&gt; syntax used to catch exceptions.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;try
&lt;&#x2F;span&gt;&lt;span&gt;        f n
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with &lt;&#x2F;span&gt;&lt;span&gt;Sign &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;            Printf.printf &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Caught %d&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; n
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;Failure &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;            Printf.printf &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Caught %s&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; s
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The function &lt;code&gt;g&lt;&#x2F;code&gt; will try running &lt;code&gt;f n&lt;&#x2F;code&gt;, but if that raises an exception, it will be caught in &lt;code&gt;with&lt;&#x2F;code&gt;. It can be pattern matched for different exception types.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Operational Semantics</title>
		<published>2022-02-17T00:00:00+00:00</published>
		<updated>2022-02-17T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/operational-semantics/" type="text/html"/>
		<id>https://sharifhsn.github.io/operational-semantics/</id>
		<content type="html">&lt;p&gt;What are the formal semantics of how a programming language works, mathematically? That&#x27;s a broad topic. &lt;strong&gt;Operational semantics&lt;&#x2F;strong&gt;, which are how programs &lt;em&gt;execute&lt;&#x2F;em&gt;, are narrow enough for one article.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;rules&quot;&gt;Rules&lt;&#x2F;h2&gt;
&lt;p&gt;The basis behind the mathematics of operation are based on using &lt;strong&gt;rules&lt;&#x2F;strong&gt; to define a &lt;strong&gt;judgment&lt;&#x2F;strong&gt;. The expression &lt;code&gt;e&lt;&#x2F;code&gt; will always evaluate to the value &lt;code&gt;v&lt;&#x2F;code&gt;. We can construct a micro-OCaml through the datatypes &lt;code&gt;exp&lt;&#x2F;code&gt; and &lt;code&gt;value&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span&gt;eval: exp -&amp;gt; value
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This way of presenting semantics is called a &lt;strong&gt;definitional interpreter&lt;&#x2F;strong&gt;. &lt;code&gt;eval&lt;&#x2F;code&gt; means &lt;code&gt;exp -&amp;gt; value&lt;&#x2F;code&gt;, and we use interpretations to define the language&#x27;s meaning.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;grammar&quot;&gt;Grammar&lt;&#x2F;h2&gt;
&lt;p&gt;It is useful to define &lt;strong&gt;meta-variables&lt;&#x2F;strong&gt; which represent categories of syntax. We will list a few here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;x&lt;&#x2F;code&gt;: any identifier or variable name&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;n&lt;&#x2F;code&gt;: a numeral value&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;e&lt;&#x2F;code&gt;: any expression&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;::=&lt;&#x2F;code&gt;: meta-syntax for definition&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;|&lt;&#x2F;code&gt;: meta-syntax for variants&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;bnf&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bnf &quot;&gt;&lt;code class=&quot;language-bnf&quot; data-lang=&quot;bnf&quot;&gt;&lt;span&gt;e ::= x | n | e + e | let x = e in e
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is an important line which defines what an expression &lt;em&gt;exactly&lt;&#x2F;em&gt; is. Up until now, we have used the term expression quite loosely, so it&#x27;s good to have an exact definition in operational semantics. An expression is either an identifier, a numeral or a combination of expressions. The last variant may seem a little strange to you, but remember, &lt;code&gt;let&lt;&#x2F;code&gt; expressions are simply replacing identifiers in an expression, so they are also expressions. This is a powerful definition because it fully encompasses the &lt;strong&gt;abstract syntax tree (AST)&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can define an evaluation as &lt;code&gt;eval: exp -&amp;gt; value&lt;&#x2F;code&gt; where evaluation is the process of turning an expression into a final value (in this case an &lt;code&gt;int&lt;&#x2F;code&gt; only).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rules-of-inference&quot;&gt;Rules of Inference&lt;&#x2F;h2&gt;
&lt;p&gt;In order to prove the veracity of a judgment, we check its composite rules. For example, let&#x27;s prove that &lt;code&gt;1 + 3 ⇒ 4&lt;&#x2F;code&gt; is true. &lt;code&gt;1&lt;&#x2F;code&gt; and &lt;code&gt;3&lt;&#x2F;code&gt; are expressions in the sum function which evaluate to their own numeral value. Two values being added together is their sum, which is &lt;code&gt;4&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The notation of &lt;strong&gt;rules of inference&lt;&#x2F;strong&gt; are used to present rules in formal mathematics:&lt;&#x2F;p&gt;
&lt;p&gt;$$\frac{H_1 \mathellipsis H_n}{C}$$&lt;&#x2F;p&gt;
&lt;p&gt;If all the hypotheses are true, then the conclusion is true. If there are no hypotheses, then the conclusion is automatically true (&lt;strong&gt;axiom&lt;&#x2F;strong&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s express those same rules about numeral self evaluation and sum expressions in rules of inference:&lt;&#x2F;p&gt;
&lt;p&gt;$$\frac{e_1 ⇒ n_1 \quad e_2 =&amp;gt; n_2 \quad n_3 \ \text{is} \ n_1 + n_2}{e_1 + e_2 ⇒ n_3}$$&lt;&#x2F;p&gt;
&lt;p&gt;We can similarly describe the more complicated rules of let expressions:&lt;&#x2F;p&gt;
&lt;p&gt;$$\frac{e_1 ⇒ v1 \quad e_2\{v_1&#x2F;x\} ⇒ v_2}{\text{let} \ x = e_1 \ \text{in} \ e_2 ⇒ v_2}$$&lt;&#x2F;p&gt;
&lt;h2 id=&quot;derivations&quot;&gt;Derivations&lt;&#x2F;h2&gt;
&lt;p&gt;The &lt;strong&gt;derivation&lt;&#x2F;strong&gt; is a process in which we apply rules to an expression in succession. We take our conclusion, then break it up into its constituent rules. If any of the rules need more rules themselves, we break them up too. Think of it like a tree which expands out from the conclusion. Let&#x27;s use &lt;code&gt;let x = 4 in x + 3 ⇒ 7&lt;&#x2F;code&gt; as an example.&lt;&#x2F;p&gt;
&lt;p&gt;$$\frac{4 ⇒ 4 \quad \dfrac{4 ⇒ 4 \quad 3 ⇒ 3 \quad 7 \ \text{is}\ 4 + 3}{4 + 3 ⇒ 7}}{\text{let}\ x = 4 \ \text{in} \ x + 3 ⇒ 7}$$&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at this derivation step by step. First, we start at our conclusion. We say that &lt;code&gt;x = 4&lt;&#x2F;code&gt; in the let expression. Because &lt;code&gt;4&lt;&#x2F;code&gt; is used an expression here, we need to generate the hypothesis that the expression &lt;code&gt;4&lt;&#x2F;code&gt; will evaluate to itself, which is true from our reflective axiom. Then, we need to show that the resulting expression &lt;code&gt;4 + 3 ⇒ 7&lt;&#x2F;code&gt; is valid, which requires the sum rule of inference. Knowing that &lt;code&gt;4&lt;&#x2F;code&gt; and &lt;code&gt;3&lt;&#x2F;code&gt; evaluate to themselves and that &lt;code&gt;7&lt;&#x2F;code&gt; is the sum of those two values, then we can confirm that hypothesis and therefore the conclusion!&lt;&#x2F;p&gt;
&lt;p&gt;The way that we&#x27;ve written this derivation is recursive in nature. This is how definitional interpreters will evaluate expressions; they will search the expression for any constituent and evaluate them in turn in order to evaluate the entire expression.&lt;&#x2F;p&gt;
&lt;p&gt;$$\frac{\text{eval Num } 4 ⇒ 4 \quad \text{Plus(Ident(&amp;quot;x&amp;quot;), Num 3)}}{\text{eval Let(&amp;quot;x&amp;quot;, Num 4, Plus(Ident(&amp;quot;x&amp;quot;), Num 3))}}$$&lt;&#x2F;p&gt;
&lt;p&gt;All evaluation is mathematical proof. An expression &lt;code&gt;e&lt;&#x2F;code&gt; that provably evaluates to value &lt;code&gt;v&lt;&#x2F;code&gt; &lt;strong&gt;is&lt;&#x2F;strong&gt; &lt;code&gt;v&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;environment&quot;&gt;Environment&lt;&#x2F;h2&gt;
&lt;p&gt;From a mathematical perspective, an environment is a partial function that maps identifiers to values. Because it&#x27;s partial, not all possible identifiers are mapped, so some identifiers are undefined.&lt;&#x2F;p&gt;
&lt;p&gt;The notation for an empty environment is &lt;code&gt;•&lt;&#x2F;code&gt;, which is undefined for every identifier. We can use notation here like in OCaml lists where we can define arguments as either the nil form &lt;code&gt;•&lt;&#x2F;code&gt; or a mapping cons the rest of the environment. Lookup of a value is similarly recursive like an OCaml list. In fact, in an OCaml definitional interpreter, the environment has type &lt;code&gt;(id * value) list&lt;&#x2F;code&gt; where we can search and match mappings like a regular &lt;em&gt;association list&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We can add environment semantics to our previous understandings of judgments like so: &lt;code&gt;A; e ⇒ v&lt;&#x2F;code&gt;. Now, when we use identifiers in expressions, we can search the environment for the equivalent value and substitute it. The environment is the formal way of representing &lt;em&gt;state&lt;&#x2F;em&gt; in an operation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conditionals&quot;&gt;Conditionals&lt;&#x2F;h2&gt;
&lt;p&gt;So far all we&#x27;ve done in terms of operational semantics is define variables and perform simple sums on them. One of the greatest powers of programming is the ability to implement control flow: if this, then that. Since we&#x27;re programming functionally and not imperatively, these conditionals evaluate to expressions, not just operations, so we must have else as well to account for all cases.&lt;&#x2F;p&gt;
&lt;p&gt;To accommodate this, we must expand our earlier definition of expressions to include &lt;em&gt;equality&lt;&#x2F;em&gt; and the &lt;em&gt;if expression&lt;&#x2F;em&gt;. The if expression takes an equality expression as a conditional, and if it satisfies the boolean argument then the if body is returned as the evaluation, else the else body.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;&quot;&gt;&lt;&#x2F;h1&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Tail Recursion in OCaml</title>
		<published>2022-02-15T00:00:00+00:00</published>
		<updated>2022-02-15T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/tail-recursion/" type="text/html"/>
		<id>https://sharifhsn.github.io/tail-recursion/</id>
		<content type="html">&lt;p&gt;Recursion in many languages can cause significant overhead. It might seem that the excess amount of recursion in OCaml would decrease its performance. But it actually doesn&#x27;t, and that&#x27;s thanks to &lt;strong&gt;tail recursion&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;implementing-reverse&quot;&gt;Implementing Reverse&lt;&#x2F;h2&gt;
&lt;p&gt;In a functional language with a linked list, it&#x27;s not a trivial task to reverse a list. There are multiple ways to do it, and they have different performance implications.&lt;&#x2F;p&gt;
&lt;p&gt;The most basic implementation would just be to concatenate backwards.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rev &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;xs &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; (rev xs) @ [x]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unfortunately, there&#x27;s a problem with this. Every time we call &lt;code&gt;rev&lt;&#x2F;code&gt; recursively, we must initialize a new stack frame for every recursive call, leaving the value &lt;code&gt;x&lt;&#x2F;code&gt; in &lt;code&gt;[x]&lt;&#x2F;code&gt; in the calling stack.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span&gt;rev [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt; → (rev [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt; → ((rev [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt; → (((rev &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]&lt;&#x2F;span&gt;&lt;span&gt;) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt; → ((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;@ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt; → ([&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;] @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]) @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt; → [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;] @ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt; → [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, there are a total of three stack frames for a list with three elements. This is pretty bad. However, we can rewrite this function to use tail recursion.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rev_helper &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l acc &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; acc
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;xs &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; rev_helper xs (x :: acc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rev &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;= rev_helper l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There doesn&#x27;t need to be any stack frame here because there are no local variables. The only thing that&#x27;s being returned is the function call to &lt;code&gt;rev_helper&lt;&#x2F;code&gt;, so the stack can simply change to the &lt;code&gt;rev_helper&lt;&#x2F;code&gt; call without saving the previous stack frame. This tail recursion is incredibly powerful.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll repeat it to be clear. Tail recursion works when the return value of a recursive function is &lt;em&gt;only&lt;&#x2F;em&gt; the recursive function call. The reason that the previous &lt;code&gt;rev&lt;&#x2F;code&gt; function didn&#x27;t work is because the return value was &lt;code&gt;(rev xs) @ [x]&lt;&#x2F;code&gt;, so &lt;code&gt;x&lt;&#x2F;code&gt; must be saved in a stack frame in order to remember it.&lt;&#x2F;p&gt;
&lt;p&gt;However, you might have noticed that we had to include a new variable called &lt;code&gt;acc&lt;&#x2F;code&gt;. This accumulator variable is a common pattern for when we want to have tail recursion since the &lt;code&gt;acc&lt;&#x2F;code&gt; is located inside the function call as an argument.&lt;&#x2F;p&gt;
&lt;p&gt;The power of tail recursion can not be understated here. In a typical function, having excessive stack frames can easily cause a stack overflow for a large data set. With tail recursion, we can have both the lack of side effects associated with recursion and the performance associated with iteration.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;general-tail-recursion-pattern&quot;&gt;General Tail Recursion Pattern&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;aux &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;arg acc &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* base case *) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;then&lt;&#x2F;span&gt;&lt;span&gt; acc
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;arg&amp;#39; &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* next argument *)
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;acc&amp;#39; &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* updated accumulator *)
&lt;&#x2F;span&gt;&lt;span&gt;            aux arg&amp;#39; acc&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;    aux x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* initial value of accumulator e.g. 0, []*)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Higher Order Functions in OCaml</title>
		<published>2022-02-08T00:00:00+00:00</published>
		<updated>2022-02-08T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/higher-order-functions/" type="text/html"/>
		<id>https://sharifhsn.github.io/higher-order-functions/</id>
		<content type="html">&lt;p&gt;We can do a lot of cool things with functions besides calling them in OCaml.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;anonymous-functions&quot;&gt;Anonymous Functions&lt;&#x2F;h2&gt;
&lt;p&gt;Values are a subset of expressions, as previously stated. All expressions can evaluate to values, but values are final.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Anonymous functions&lt;&#x2F;strong&gt; are also values. Sometimes, it&#x27;s more convenient not to create and name a whole new function for our purpose. Anonymous functions are ad hoc functions that exist as values in expressions. They are expressed using the keyword &lt;code&gt;fun&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span&gt;= fun x -&amp;gt; x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This might not seem to have much benefit compared to a full function definition, but it is very useful within &lt;code&gt;let&lt;&#x2F;code&gt; expressions. Since anonymous functions are values, not just expressions, they can be manipulated far more powerfully than even general expressions.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span&gt;= (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;z &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; z - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) y
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This code might seem a little hard to parse, but it&#x27;s easier to think about if we rewrite it to use traditional function definitions.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;g &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;z &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    z - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span&gt;= f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;g y
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can tell that &lt;code&gt;y&lt;&#x2F;code&gt; is 3 in the function &lt;code&gt;g&lt;&#x2F;code&gt;, which then evaluates to 1. However, the former code snippet is a much terser way to write this expression  if we don&#x27;t need the functions &lt;code&gt;f&lt;&#x2F;code&gt; and &lt;code&gt;g&lt;&#x2F;code&gt; anymore.&lt;&#x2F;p&gt;
&lt;p&gt;One good way to think about it is that anonymous functions are to regular functions as literals are to variables. If we only need to use the value &lt;code&gt;&amp;quot;really_long_string&amp;quot;&lt;&#x2F;code&gt; once, we don&#x27;t need to store it in a variable. On the other hand, it can be useful to store that literal in a variable &lt;code&gt;s&lt;&#x2F;code&gt; that is much shorter to write. Similarly, if we only need to use the function &lt;code&gt;x -&amp;gt; x + 1&lt;&#x2F;code&gt; once, we don&#x27;t need to store it in a function variable.&lt;&#x2F;p&gt;
&lt;p&gt;In fact, this isn&#x27;t even an analogy. Functions are first-class in OCaml, so regular functions are just variables that store anonymous functions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;= body
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* this is sugar for this *)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f &lt;&#x2F;span&gt;&lt;span&gt;= fun x -&amp;gt; body
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And in the same vein, we can name functions within &lt;code&gt;let&lt;&#x2F;code&gt; expressions in an anonymous ways.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l x &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;left &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;= x - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;right &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;= x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;then&lt;&#x2F;span&gt;&lt;span&gt; left x
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else&lt;&#x2F;span&gt;&lt;span&gt;      right x
&lt;&#x2F;span&gt;&lt;span&gt;;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* same as *)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;move&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l x &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;then &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; y - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) x
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else      &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;y &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; y + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note also that the local variable in the anonymous function doesn&#x27;t actually matter to the expression it&#x27;s used in; this is a consequence of the shadowing rules of OCaml.&lt;&#x2F;p&gt;
&lt;p&gt;There are several functions in the standard library of OCaml that use higher order functions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;map&quot;&gt;Map&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;map&lt;&#x2F;code&gt; is a function in the &lt;code&gt;List&lt;&#x2F;code&gt; module of OCaml. Like the name implies, this function maps a function onto every element of a list and returns that list. It has type &lt;code&gt;(&#x27;a -&amp;gt; &#x27;b) -&amp;gt; &#x27;a list -&amp;gt; &#x27;b list&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;map &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; (f h) :: (map f t)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a simple, yet powerful and useful function. That&#x27;s why it is included in the &lt;code&gt;List&lt;&#x2F;code&gt; module, although it&#x27;s trivial to write yourself.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fold&quot;&gt;Fold&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;fold&lt;&#x2F;code&gt; is another function in the &lt;code&gt;List&lt;&#x2F;code&gt; module in OCaml, that iterates over a list. The essential idea is that you have an accumulator variable that you want to get based on the values in a list. &lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fold &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f acc l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; acc
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; fold f (f acc h) t
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For example, this is a way to implement a sum function using &lt;code&gt;fold&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;acc l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; acc
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; sum (acc + h) t
&lt;&#x2F;span&gt;&lt;span&gt;sum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;53&lt;&#x2F;span&gt;&lt;span&gt;];;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* same as *)
&lt;&#x2F;span&gt;&lt;span&gt;fold (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fun &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;acc x &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; acc + x) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;53&lt;&#x2F;span&gt;&lt;span&gt;];;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Its type is &lt;code&gt;(&#x27;a -&amp;gt; &#x27;b -&amp;gt; &#x27;a) -&amp;gt; &#x27;a -&amp;gt; &#x27;b list -&amp;gt; &#x27;a&lt;&#x2F;code&gt;. We can deconstruct that and understand each part of the function. The initial function &lt;code&gt;f&lt;&#x2F;code&gt; applies the type &lt;code&gt;&#x27;b&lt;&#x2F;code&gt; to &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; and returns &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. Then for the next two arguments, we keep the same &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; accumulator and iterate over the &lt;code&gt;&#x27;b list&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The use of an accumulator makes &lt;code&gt;fold&lt;&#x2F;code&gt; very versatile, since you can put anything in there.&lt;&#x2F;p&gt;
&lt;p&gt;We can combine &lt;code&gt;map&lt;&#x2F;code&gt; and &lt;code&gt;fold&lt;&#x2F;code&gt; to create the &lt;em&gt;map&#x2F;reduce&lt;&#x2F;em&gt; framework which can be massively parallelized. We first map a function over our list, then we reduce the list into a single accumulator value.&lt;&#x2F;p&gt;
&lt;p&gt;There is also an alternative version of &lt;code&gt;fold&lt;&#x2F;code&gt; called &lt;code&gt;fold_right&lt;&#x2F;code&gt; that works in reverse, which can be better for certain problems. However, it comes with steep performance cost: every recursive call builds a new stack frame. The original &lt;code&gt;fold&lt;&#x2F;code&gt; is able to optimize this call away by using tail recursion.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Lets, Tuples, and Records in OCaml</title>
		<published>2022-02-03T00:00:00+00:00</published>
		<updated>2022-02-03T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/lets-tuples-records/" type="text/html"/>
		<id>https://sharifhsn.github.io/lets-tuples-records/</id>
		<content type="html">&lt;p&gt;Lists are the most basic data structure in OCaml, but there are others that we need to be aware of.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;let-expressions&quot;&gt;Let Expressions&lt;&#x2F;h2&gt;
&lt;p&gt;We have seen the keyword &lt;code&gt;let&lt;&#x2F;code&gt; used to define expressions and store values. However, the same keyword can be used to create expressions which bind variables in other expressions. The &lt;code&gt;let&lt;&#x2F;code&gt; &lt;em&gt;statements&lt;&#x2F;em&gt; we used before do not evaluate to any value, while &lt;strong&gt;let expressions&lt;&#x2F;strong&gt; do evaluate.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; x * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;in&lt;&#x2F;code&gt; keyword gives us a clue on what&#x27;s going on. You can think of it almost like a function where we replace variables in the inner expression with the values in the outer expression. The expression above evaluates to 15, because it is &lt;code&gt;x * 3&lt;&#x2F;code&gt; &lt;em&gt;in&lt;&#x2F;em&gt; which &lt;code&gt;x&lt;&#x2F;code&gt; is 5.&lt;&#x2F;p&gt;
&lt;p&gt;We can type check this expression where &lt;code&gt;x&lt;&#x2F;code&gt; has the same type of the binding expression.&lt;&#x2F;p&gt;
&lt;p&gt;If you omit &lt;code&gt;in&lt;&#x2F;code&gt;, you can think of that as a &lt;code&gt;let&lt;&#x2F;code&gt; expression which is bound in the global scope instead of the scope of the body expression.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;37&lt;&#x2F;span&gt;&lt;span&gt;;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this statement &lt;code&gt;x&lt;&#x2F;code&gt; is defined as 37 in the global scope and it can be used elsewhere.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve used the word &lt;em&gt;scope&lt;&#x2F;em&gt; a lot here, so let&#x27;s define that a little more concretely. In the above &lt;code&gt;let&lt;&#x2F;code&gt; expression, the variable &lt;code&gt;x&lt;&#x2F;code&gt; is not visible in any other part of the program. Let&#x27;s imagine that we have both of these lines together, the &lt;code&gt;let&lt;&#x2F;code&gt; expression and the &lt;code&gt;let&lt;&#x2F;code&gt; statement. They&#x27;re both named &lt;code&gt;x&lt;&#x2F;code&gt;, so what would the value be?&lt;&#x2F;p&gt;
&lt;p&gt;We can imagine evaluating expressions right to left, and upon encountering a variable, act like it is a pointer to an expression in the outer scope. In the innermost scope, the expression is &lt;code&gt;x * 3&lt;&#x2F;code&gt;. This expression has no meaning because &lt;code&gt;x&lt;&#x2F;code&gt; is a variable, so we back up one scope and check if &lt;code&gt;x&lt;&#x2F;code&gt; is defined. And in fact, it is! So we will replace the &lt;code&gt;x&lt;&#x2F;code&gt; in that expression with 5. Note that even though &lt;code&gt;x&lt;&#x2F;code&gt; is defined as 37 in the global scope, the inner scope &lt;strong&gt;shadows&lt;&#x2F;strong&gt; the global scope.&lt;&#x2F;p&gt;
&lt;p&gt;Shadowing refers to when a variable name is rebound in an inner scope to have a different meaning. Some languages, such as Java, do not allow you to do this because of possible confusion. However, it is sometimes useful to use the same name for different things, so languages like C and OCaml permit shadowing.&lt;&#x2F;p&gt;
&lt;p&gt;You can also use &lt;code&gt;let&lt;&#x2F;code&gt; expressions inside a function, and this is often good style because it clarifies constants:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;area &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;d &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pi &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3.14 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;r &lt;&#x2F;span&gt;&lt;span&gt;= d &#x2F;. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2.0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;    pi *. r *. r
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Much better than C &lt;code&gt;#define&lt;&#x2F;code&gt;, right?&lt;&#x2F;p&gt;
&lt;p&gt;OCaml does not permit you to mutate variables. However, you can simulate this by shadowing a variable with a new value:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;;
&lt;&#x2F;span&gt;&lt;span&gt;x = x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* not allowed! *)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;= x + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* allowed, but discouraged *)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is kind of an ugly hack so you should avoid it in real code, though it is technically possible under OCaml&#x27;s rules.&lt;&#x2F;p&gt;
&lt;p&gt;We can nest &lt;code&gt;let&lt;&#x2F;code&gt; expressions, but this is generally bad practice like shadowing. Realistically, it&#x27;s usually better to just write linear expressions.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;let&lt;&#x2F;code&gt; expressions don&#x27;t just have to use a plain variable. We can also use patterns to bind expressions, and if the binding expressions fails to match the pattern then we have an exception. This is useful when we want to extract a particular value from an expression.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;[x] = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;:: x &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(*  evaluates to [1; 1*)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;tuples&quot;&gt;Tuples&lt;&#x2F;h2&gt;
&lt;p&gt;Tuples represent collections, like lists, but they contain a fixed amount of values. The tradeoff is that they can be &lt;em&gt;heterogenous&lt;&#x2F;em&gt;, which means they can have multiple types. The type of a tuple is the type of each of its component, separated by asterisks.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* int * int *)
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3.5&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* int * string * float *)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Because each tuple has a distinct type, a list of tuples can only have one type of tuples in it.&lt;&#x2F;p&gt;
&lt;p&gt;Tuples lend themselves particularly well to pattern matching. Instead of having multiple function arguments like is typical in OCaml, we can have one argument that is a tuple and then pattern match it in order to destructure it. This is also a convenient way to return multiple variables from a function, which is otherwise not allowed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;records&quot;&gt;Records&lt;&#x2F;h2&gt;
&lt;p&gt;Each element of a tuple is referenced by its position. Sometimes, we want to reference elements by name, like in a dictionary. For this use, we use &lt;strong&gt;records&lt;&#x2F;strong&gt;. Records are a distinct type that must be pre-defined before being used.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type date &lt;&#x2F;span&gt;&lt;span&gt;= { month: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;; day: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;; year: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now, we can construct records by using the same brace notation but giving each name a value.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;today &lt;&#x2F;span&gt;&lt;span&gt;= { day=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;; year=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2022&lt;&#x2F;span&gt;&lt;span&gt;; month=&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;^&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;eb&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot; };;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You might notice that this has a similar syntax to C-style structs. The fields can be accessed through &lt;code&gt;.&lt;&#x2F;code&gt; syntax as in &lt;code&gt;today.day&lt;&#x2F;code&gt;, and the order of the struct assignment doesn&#x27;t matter.&lt;&#x2F;p&gt;
&lt;p&gt;Records can also be conveniently destructured, like all other data structures. &lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Lists in OCaml</title>
		<published>2022-01-27T00:00:00+00:00</published>
		<updated>2022-01-27T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/lists/" type="text/html"/>
		<id>https://sharifhsn.github.io/lists/</id>
		<content type="html">&lt;p&gt;Lists are the most basic data structure in OCaml. The most analoguous structure is a vector in C++ or Rust. Lists are &lt;em&gt;homogenous&lt;&#x2F;em&gt; and of &lt;em&gt;arbitrary length&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;The most basic list is &lt;strong&gt;nil&lt;&#x2F;strong&gt;, the empty list: &lt;code&gt;[]&lt;&#x2F;code&gt;. We can prepend elements to a list through the &lt;strong&gt;cons&lt;&#x2F;strong&gt; operator: &lt;code&gt;::&lt;&#x2F;code&gt;. Every display of a list is actually just syntactic sugar for every element being cons with the empty list:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;] = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Importantly, lists are immutable! When they are created, they cannot be changed. If you want to add an element to a list, you must construct a new list based on the old one.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;This might seem inefficient, to create a new list every time we want to change it. But the semantics of a language do not necessarily correspond to its compiled execution. In particular, the invariant that lists are immutable can lead to optimizations where a compiler doesn&#x27;t need to keep track of mutated information.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;It is convention to call the right hand side the &lt;em&gt;tail&lt;&#x2F;em&gt; and the left hand side the &lt;em&gt;head&lt;&#x2F;em&gt;. The cons operator has an element on the left side and an list on the right side.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s think of lists in terms of expressions. &lt;code&gt;[]&lt;&#x2F;code&gt; is a value like 0 or 1. The cons operator evaluates the left expression to an element and the right expression to a list of type element. Like with function arguments, the order of this evaluation is irrelevant as long as we don&#x27;t introduce side effects.&lt;&#x2F;p&gt;
&lt;p&gt;Lists can also have the &lt;strong&gt;polymorphic&lt;&#x2F;strong&gt; type &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;. This is similar to a generic type in languages like Java, C++, and Rust. An &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; list can have any type. This is most useful when it comes to function types. If the function type accepts or returns a &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; type, then it is a generic function that can be used on a list of any type. Nil is a &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; list.&lt;&#x2F;p&gt;
&lt;p&gt;You can also have nested lists like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;m &lt;&#x2F;span&gt;&lt;span&gt;= [[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;]; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;]] ;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* int list list *)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unlike tuples, these lists do not have to be the same size. They do need to have the same type, however, so this is a list of int lists, or an &lt;code&gt;int list list&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The cons operator &lt;em&gt;does not&lt;&#x2F;em&gt; work to concatenate two lists. It can only add one element to an existing list. This is a very common bug (at least for myself). OCaml has a special sugar operand &lt;code&gt;@&lt;&#x2F;code&gt; to concatenate lists, although it is technically an ordinary function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pattern-matching&quot;&gt;Pattern Matching&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Pattern matching&lt;&#x2F;strong&gt; is an extremely important concept in OCaml for functional programming. It allows for powerful destructuring of enums, collections, and other complex objects.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;head &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h&lt;&#x2F;span&gt;&lt;span&gt; :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; h
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function &lt;code&gt;head&lt;&#x2F;code&gt; here matches the list &lt;code&gt;l&lt;&#x2F;code&gt; where there is an element &lt;code&gt;h&lt;&#x2F;code&gt; that is cons with an arbitrary expression. The &lt;code&gt;_&lt;&#x2F;code&gt; indicates that some expression must be present, but we don&#x27;t care about what expression it is, and in fact we are throwing it away. &lt;code&gt;h&lt;&#x2F;code&gt; is also an arbitrary expression, but we are using it as the return type.&lt;&#x2F;p&gt;
&lt;p&gt;This match statement is not &lt;em&gt;exhaustive&lt;&#x2F;em&gt;. An exhaustive match means that there is an evaluation for every possible case of &lt;code&gt;l&lt;&#x2F;code&gt;. Here, there is no case for when &lt;code&gt;l&lt;&#x2F;code&gt; is nil. This does not work in OCaml; every match must be exhaustive. Here is an example of an exhaustive match:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;sum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;h &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; h + sum t
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;sum&lt;&#x2F;code&gt; function works for every case of &lt;code&gt;l&lt;&#x2F;code&gt;. Either it is nil, or it is a head cons a tail. You will also notice here that the two cases resolve to the same type. This is another requirement for match statements: all patterns must evaluate to the same type, which is not necessarily the type of the initial expression. Here, the initial expression has the type &lt;code&gt;int list&lt;&#x2F;code&gt; and the return expression has the type &lt;code&gt;int&lt;&#x2F;code&gt;. This function only works for &lt;code&gt;int list&lt;&#x2F;code&gt;. This restriction is not present for our &lt;code&gt;head&lt;&#x2F;code&gt; function because &lt;code&gt;h&lt;&#x2F;code&gt; is polymorphic type &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Pattern matching is generally much better than its alternatives. OCaml will warn you if your function is non-exhaustive, and it will throw an exception for an unhandled case. Also, duplicated cases are easy to avoid becaues OCaml will give a similar warning for unused cases.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;recursion-with-lists&quot;&gt;Recursion with Lists&lt;&#x2F;h2&gt;
&lt;p&gt;In order to manipulate lists in any significant way, we need to use recursion. Lists are immutable, so functions over them must be recursive.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;length &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt; :: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;+ length t
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can think of this as recursive because we have our base case of nil and our iterative step of applying the function to successive tails. This function does not use &lt;code&gt;h&lt;&#x2F;code&gt;, but we might, as in the &lt;code&gt;sum&lt;&#x2F;code&gt; function above. Recursion might seem like it incurs overhead here, as in C-like languages recursion typically costs stack frames. However, OCaml knows that even though you are writing your code recursively, all you&#x27;re doing is iterating over an immutable list, so it will elide those issues. Such recursive functions are called &lt;strong&gt;tail-recursive&lt;&#x2F;strong&gt; and are essential to the use of functional languages.&lt;&#x2F;p&gt;
&lt;p&gt;However, these functions work through the lists forward, like a linked list. How can we do something like reversing a list?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rev_aux &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l acc &lt;&#x2F;span&gt;&lt;span&gt;=
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;with
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[] &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; acc
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;x &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;xs &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; rev_aux xs (x :: acc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;rev &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;l &lt;&#x2F;span&gt;&lt;span&gt;= rev_aux l &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;[]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The key here is the variable &lt;code&gt;acc&lt;&#x2F;code&gt;, which is known as an &lt;strong&gt;accumulator&lt;&#x2F;strong&gt;. This is a variable that is included with each recursive function call that accumulates operations on it. This is a way of simulating side effects in a controlled way which is often useful. &lt;code&gt;acc&lt;&#x2F;code&gt; will accumulate heads while the tail grows smaller, and the actual &lt;code&gt;rev&lt;&#x2F;code&gt; function will get the accumulated nil that it passed to &lt;code&gt;rev_aux&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Functions in OCaml</title>
		<published>2022-01-25T00:00:00+00:00</published>
		<updated>2022-01-25T00:00:00+00:00</updated>
		<link href="https://sharifhsn.github.io/functions/" type="text/html"/>
		<id>https://sharifhsn.github.io/functions/</id>
		<content type="html">&lt;p&gt;A &lt;strong&gt;function&lt;&#x2F;strong&gt; takes arguments, performs operations using them, and returns a value. In OCaml, we can write functions like so&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;pre data-lang=&quot;ocaml&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-ocaml &quot;&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let rec &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fact &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;(* the function is named fact and its arg is n *)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; n = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;then &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else&lt;&#x2F;span&gt;&lt;span&gt; n * fact (n - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) ;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a &lt;em&gt;recursive&lt;&#x2F;em&gt; function, so we must prepend the keyword &lt;code&gt;rec&lt;&#x2F;code&gt; to the name of the function. The reason for this is that the function name is not automatically in scope, so if we don&#x27;t use that we won&#x27;t necessarily know what &lt;code&gt;fact&lt;&#x2F;code&gt; refers to. &lt;code&gt;rec&lt;&#x2F;code&gt; adds the function name into scope.&lt;&#x2F;p&gt;
&lt;p&gt;As you can see, the declaration of a function is fairly similar to the declaration of a variable. In fact, we can use functions as variables in OCaml! This is because functions in OCaml are &lt;em&gt;first-class functions&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;You also might have noticed here that we haven&#x27;t mentioned the type of anything. This is because the type of the function can be inferred, also known as &lt;strong&gt;type inference&lt;&#x2F;strong&gt;. This process is a normal part of type checking for correctness. The compiler itself will look for a type that the code is correct for. In this example, &lt;code&gt;n&lt;&#x2F;code&gt; is compared with an integer, so it must only be an &lt;code&gt;int&lt;&#x2F;code&gt;. The return type is &lt;code&gt;n&lt;&#x2F;code&gt; multiplied by its own return type, so that must also be &lt;code&gt;int&lt;&#x2F;code&gt;. The compiler can see without us telling it that the function is of type &lt;code&gt;int -&amp;gt; int&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;But what is that &lt;code&gt;int -&amp;gt; int&lt;&#x2F;code&gt; that I just wrote? That is the constructor for a function type. The last type indicates the return type, and all other types are the arguments in order. The function type &lt;code&gt;float -&amp;gt; int -&amp;gt; float&lt;&#x2F;code&gt;, for example, takes a &lt;code&gt;float&lt;&#x2F;code&gt; and &lt;code&gt;int&lt;&#x2F;code&gt; as its arguments and returns a &lt;code&gt;float&lt;&#x2F;code&gt;. Try looking at different OCaml functions and guessing its type as a fun exercise! :smile:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Aside: you might question why we couldn&#x27;t just get a float as a result from the multiplication. The standard operands in OCaml only apply to &lt;code&gt;int&lt;&#x2F;code&gt;, and applying them to other types is an error. In order to add &lt;code&gt;float&lt;&#x2F;code&gt;, we must use &lt;code&gt;+.&lt;&#x2F;code&gt;, not &lt;code&gt;+&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Type checking works like a proof by contradiction. We assume that a function has some type, then check if there are any logical contradictions created by this assumption. If there are, then we reject this type.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;calling-a-function&quot;&gt;Calling a Function&lt;&#x2F;h2&gt;
&lt;p&gt;Function calls (also known as &lt;em&gt;applications&lt;&#x2F;em&gt;) look very similar to function declarations; they are simply the name of the function followed by its arguments, no parentheses necessary. The type checking involved is that we check if every expression supplied as an argument corresponds to the same type as it&#x27;s supposed to. We evaluate each expression from right to left to see if they&#x27;re correct or not (though this doesn&#x27;t matter unless you have side effects).&lt;&#x2F;p&gt;
&lt;p&gt;Once we find the value for each argument, we replace each argument in the function with its value, which creates an expression that can be evaluated to the final value.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Aside: Although we have type inference, we can use &lt;em&gt;type annotations&lt;&#x2F;em&gt; with OCaml. These increase the readability of code by making the type of the variable obvious: &lt;code&gt;let (x : int) = 3&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
	</entry>
</feed>
