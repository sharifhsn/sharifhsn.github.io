<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>Higher Order Functions in OCaml</title>
    <meta name="description" content="Sharif Haason&#x27;s personal website for various notes and ideas">

    <link rel="stylesheet" href="https://sharifhsn.github.io/main.css">

    <link rel="me" href="https://fandom.ink/@sharifhsn">

    

    
        <link rel="stylesheet" href="/css/katex.min.css">
    

    
        <script defer src="/js/katex.min.js"></script>
        <script defer src="/js/mathtex-script-type.min.js"></script>
        <script defer src="/js/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>
    

    
    
</head>
<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header> 
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;sharifhsn.github.io&#x2F;">Sharif&#x27;s Page</a>
            </h1>
            <nav>
                
                
                
            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>Higher Order Functions in OCaml</h1>
    </header>
    <div class="content">
        <p>We can do a lot of cool things with functions besides calling them in OCaml.</p>
<span id="continue-reading"></span><h2 id="anonymous-functions">Anonymous Functions</h2>
<p>Values are a subset of expressions, as previously stated. All expressions can evaluate to values, but values are final.</p>
<p><strong>Anonymous functions</strong> are also values. Sometimes, it's more convenient not to create and name a whole new function for our purpose. Anonymous functions are ad hoc functions that exist as values in expressions. They are expressed using the keyword <code>fun</code>.</p>
<pre data-lang="ocaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#b48ead;">let </span><span style="color:#bf616a;">y </span><span>= fun x -&gt; x + </span><span style="color:#d08770;">3
</span></code></pre>
<p>This might not seem to have much benefit compared to a full function definition, but it is very useful within <code>let</code> expressions. Since anonymous functions are values, not just expressions, they can be manipulated far more powerfully than even general expressions.</p>
<pre data-lang="ocaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#b48ead;">let </span><span style="color:#bf616a;">y </span><span>= (</span><span style="color:#b48ead;">fun </span><span style="color:#bf616a;">x </span><span>-&gt; x + </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#d08770;">2 </span><span style="color:#b48ead;">in
</span><span>(</span><span style="color:#b48ead;">fun </span><span style="color:#bf616a;">z </span><span>-&gt; z - </span><span style="color:#d08770;">2</span><span>) y
</span></code></pre>
<p>This code might seem a little hard to parse, but it's easier to think about if we rewrite it to use traditional function definitions.</p>
<pre data-lang="ocaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">f </span><span style="color:#bf616a;">x </span><span>=
</span><span>    x + </span><span style="color:#d08770;">1
</span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">g </span><span style="color:#bf616a;">z </span><span>=
</span><span>    z - </span><span style="color:#d08770;">2
</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">y </span><span>= f </span><span style="color:#d08770;">2 </span><span style="color:#b48ead;">in
</span><span>g y
</span></code></pre>
<p>Now we can tell that <code>y</code> is 3 in the function <code>g</code>, which then evaluates to 1. However, the former code snippet is a much terser way to write this expression  if we don't need the functions <code>f</code> and <code>g</code> anymore.</p>
<p>One good way to think about it is that anonymous functions are to regular functions as literals are to variables. If we only need to use the value <code>&quot;really_long_string&quot;</code> once, we don't need to store it in a variable. On the other hand, it can be useful to store that literal in a variable <code>s</code> that is much shorter to write. Similarly, if we only need to use the function <code>x -&gt; x + 1</code> once, we don't need to store it in a function variable.</p>
<p>In fact, this isn't even an analogy. Functions are first-class in OCaml, so regular functions are just variables that store anonymous functions:</p>
<pre data-lang="ocaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">f </span><span style="color:#bf616a;">x </span><span>= body
</span><span style="color:#65737e;">(* this is sugar for this *)
</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">f </span><span>= fun x -&gt; body
</span></code></pre>
<p>And in the same vein, we can name functions within <code>let</code> expressions in an anonymous ways.</p>
<pre data-lang="ocaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">move </span><span style="color:#bf616a;">l x </span><span>=
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">left </span><span style="color:#bf616a;">x </span><span>= x - </span><span style="color:#d08770;">1 </span><span style="color:#b48ead;">in
</span><span>    </span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">right </span><span style="color:#bf616a;">x </span><span>= x + </span><span style="color:#d08770;">1 </span><span style="color:#b48ead;">in
</span><span>    </span><span style="color:#b48ead;">if</span><span> l </span><span style="color:#b48ead;">then</span><span> left x
</span><span>    </span><span style="color:#b48ead;">else</span><span>      right x
</span><span>;;
</span><span style="color:#65737e;">(* same as *)
</span><span style="color:#b48ead;">let </span><span style="color:#8fa1b3;">move&#39; </span><span style="color:#bf616a;">l x </span><span>=
</span><span>    </span><span style="color:#b48ead;">if</span><span> l </span><span style="color:#b48ead;">then </span><span>(</span><span style="color:#b48ead;">fun </span><span style="color:#bf616a;">y </span><span>-&gt; y - </span><span style="color:#d08770;">1</span><span>) x
</span><span>    </span><span style="color:#b48ead;">else      </span><span>(</span><span style="color:#b48ead;">fun </span><span style="color:#bf616a;">y </span><span>-&gt; y + </span><span style="color:#d08770;">1</span><span>) x
</span></code></pre>
<p>Note also that the local variable in the anonymous function doesn't actually matter to the expression it's used in; this is a consequence of the shadowing rules of OCaml.</p>
<p>There are several functions in the standard library of OCaml that use higher order functions.</p>
<h2 id="map">Map</h2>
<p><code>map</code> is a function in the <code>List</code> module of OCaml. Like the name implies, this function maps a function onto every element of a list and returns that list. It has type <code>('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</code>.</p>
<pre data-lang="ocaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#b48ead;">let rec </span><span style="color:#8fa1b3;">map </span><span style="color:#bf616a;">f l </span><span>=
</span><span>    </span><span style="color:#b48ead;">match</span><span> l </span><span style="color:#b48ead;">with
</span><span>    </span><span style="color:#b48ead;">| </span><span style="color:#d08770;">[] </span><span>-&gt; </span><span style="color:#d08770;">[]
</span><span>    </span><span style="color:#b48ead;">| </span><span style="color:#bf616a;">h </span><span>:: </span><span style="color:#bf616a;">t </span><span>-&gt; (f h) :: (map f t)
</span></code></pre>
<p>This is a simple, yet powerful and useful function. That's why it is included in the <code>List</code> module, although it's trivial to write yourself.</p>
<h2 id="fold">Fold</h2>
<p><code>fold</code> is another function in the <code>List</code> module in OCaml, that iterates over a list. The essential idea is that you have an accumulator variable that you want to get based on the values in a list. </p>
<pre data-lang="ocaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#b48ead;">let rec </span><span style="color:#8fa1b3;">fold </span><span style="color:#bf616a;">f acc l </span><span>=
</span><span>    </span><span style="color:#b48ead;">match</span><span> l </span><span style="color:#b48ead;">with
</span><span>    </span><span style="color:#b48ead;">| </span><span style="color:#d08770;">[] </span><span>-&gt; acc
</span><span>    </span><span style="color:#b48ead;">| </span><span style="color:#bf616a;">h </span><span>:: </span><span style="color:#bf616a;">t </span><span>-&gt; fold f (f acc h) t
</span></code></pre>
<p>For example, this is a way to implement a sum function using <code>fold</code>.</p>
<pre data-lang="ocaml" style="background-color:#2b303b;color:#c0c5ce;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#b48ead;">let rec </span><span style="color:#8fa1b3;">sum </span><span style="color:#bf616a;">acc l </span><span>=
</span><span>    </span><span style="color:#b48ead;">match</span><span> l </span><span style="color:#b48ead;">with
</span><span>    </span><span style="color:#b48ead;">| </span><span style="color:#d08770;">[] </span><span>-&gt; acc
</span><span>    </span><span style="color:#b48ead;">| </span><span style="color:#bf616a;">h </span><span>:: </span><span style="color:#bf616a;">t </span><span>-&gt; sum (acc + h) t
</span><span>sum </span><span style="color:#d08770;">0 </span><span>[</span><span style="color:#d08770;">2</span><span>; </span><span style="color:#d08770;">5</span><span>; </span><span style="color:#d08770;">100</span><span>; </span><span style="color:#d08770;">53</span><span>];;
</span><span style="color:#65737e;">(* same as *)
</span><span>fold (</span><span style="color:#b48ead;">fun </span><span style="color:#bf616a;">acc x </span><span>-&gt; acc + x) </span><span style="color:#d08770;">0 </span><span>[</span><span style="color:#d08770;">2</span><span>; </span><span style="color:#d08770;">5</span><span>; </span><span style="color:#d08770;">100</span><span>; </span><span style="color:#d08770;">53</span><span>];;
</span></code></pre>
<p>Its type is <code>('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a</code>. We can deconstruct that and understand each part of the function. The initial function <code>f</code> applies the type <code>'b</code> to <code>'a</code> and returns <code>'a</code>. Then for the next two arguments, we keep the same <code>'a</code> accumulator and iterate over the <code>'b list</code>.</p>
<p>The use of an accumulator makes <code>fold</code> very versatile, since you can put anything in there.</p>
<p>We can combine <code>map</code> and <code>fold</code> to create the <em>map/reduce</em> framework which can be massively parallelized. We first map a function over our list, then we reduce the list into a single accumulator value.</p>
<p>There is also an alternative version of <code>fold</code> called <code>fold_right</code> that works in reverse, which can be better for certain problems. However, it comes with steep performance cost: every recursive call builds a new stack frame. The original <code>fold</code> is able to optimize this call away by using tail recursion.</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date"> 8 February 2022</div>
        
        <div class="article-taxonomies">
            
                <ul class="article-categories">
                    
                    <li><a href="https://sharifhsn.github.io/categories/principles-of-programming-languages/">Principles of Programming Languages</a></li>
                    
                </ul>
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://sharifhsn.github.io/tags/cs314/">#cs314</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                © Sharif&#x27;s Page 2022<br>
                Powered by <a target="_blank" href="https://getzola.org/">Zola</a>, Theme <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>
</html>
